
build/ohc-arduino-8mhz.elf:     file format elf32-avr


Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
   4:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
   8:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
   c:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  10:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  14:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  18:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  1c:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  20:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  24:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  28:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  2c:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  30:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  34:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  38:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  3c:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  40:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  44:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  48:	0c 94 48 00 	jmp	0x90	; 0x90 <__vector_18>
  4c:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  50:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  54:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  58:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  5c:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  60:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  64:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>

00000068 <__ctors_end>:
  68:	11 24       	eor	r1, r1
  6a:	1f be       	out	0x3f, r1	; 63
  6c:	cf ef       	ldi	r28, 0xFF	; 255
  6e:	d8 e0       	ldi	r29, 0x08	; 8
  70:	de bf       	out	0x3e, r29	; 62
  72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_clear_bss>:
  74:	12 e0       	ldi	r17, 0x02	; 2
  76:	a0 e0       	ldi	r26, 0x00	; 0
  78:	b1 e0       	ldi	r27, 0x01	; 1
  7a:	01 c0       	rjmp	.+2      	; 0x7e <.do_clear_bss_start>

0000007c <.do_clear_bss_loop>:
  7c:	1d 92       	st	X+, r1

0000007e <.do_clear_bss_start>:
  7e:	a0 32       	cpi	r26, 0x20	; 32
  80:	b1 07       	cpc	r27, r17
  82:	e1 f7       	brne	.-8      	; 0x7c <.do_clear_bss_loop>
  84:	0e 94 b0 00 	call	0x160	; 0x160 <main>
  88:	0c 94 3b 07 	jmp	0xe76	; 0xe76 <_exit>

0000008c <__bad_interrupt>:
  8c:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000090 <__vector_18>:
    }

    return 0;
}

ISR(USART_RX_vect) {
  90:	1f 92       	push	r1
  92:	0f 92       	push	r0
  94:	0f b6       	in	r0, 0x3f	; 63
  96:	0f 92       	push	r0
  98:	11 24       	eor	r1, r1
  9a:	2f 93       	push	r18
  9c:	3f 93       	push	r19
  9e:	4f 93       	push	r20
  a0:	5f 93       	push	r21
  a2:	8f 93       	push	r24
  a4:	9f 93       	push	r25
  a6:	af 93       	push	r26
  a8:	bf 93       	push	r27
  aa:	ef 93       	push	r30
  ac:	ff 93       	push	r31
    uint8_t rx = UDR0;
  ae:	80 91 c6 00 	lds	r24, 0x00C6

    packet_checksum ^= packet_buffer[packet_head];
  b2:	20 91 00 01 	lds	r18, 0x0100
  b6:	e2 2f       	mov	r30, r18
  b8:	f0 e0       	ldi	r31, 0x00	; 0
  ba:	eb 5f       	subi	r30, 0xFB	; 251
  bc:	fe 4f       	sbci	r31, 0xFE	; 254
  be:	90 81       	ld	r25, Z
  c0:	30 91 01 01 	lds	r19, 0x0101
    packet_buffer[packet_head] = rx;
  c4:	80 83       	st	Z, r24
    packet_checksum ^= rx;
  c6:	38 27       	eor	r19, r24
  c8:	39 27       	eor	r19, r25
  ca:	30 93 01 01 	sts	0x0101, r19
    packet_head++;
  ce:	2f 5f       	subi	r18, 0xFF	; 255
  d0:	20 93 00 01 	sts	0x0100, r18
    if (packet_head >= PACKET_SIZE)
  d4:	24 38       	cpi	r18, 0x84	; 132
  d6:	18 f0       	brcs	.+6      	; 0xde <__vector_18+0x4e>
        packet_head = 0;
  d8:	10 92 00 01 	sts	0x0100, r1
  dc:	20 e0       	ldi	r18, 0x00	; 0

    if (packet_buffer[packet_head] == PACKET_HEADER) {
  de:	e2 2f       	mov	r30, r18
  e0:	f0 e0       	ldi	r31, 0x00	; 0
  e2:	df 01       	movw	r26, r30
  e4:	ab 5f       	subi	r26, 0xFB	; 251
  e6:	be 4f       	sbci	r27, 0xFE	; 254
  e8:	8c 91       	ld	r24, X
  ea:	85 35       	cpi	r24, 0x55	; 85
  ec:	79 f0       	breq	.+30     	; 0x10c <__vector_18+0x7c>
                new_packet[i] = packet_buffer[i-num];
            has_new_packet = 1;
            packet_type = new_packet[1];
        }
    }
}
  ee:	ff 91       	pop	r31
  f0:	ef 91       	pop	r30
  f2:	bf 91       	pop	r27
  f4:	af 91       	pop	r26
  f6:	9f 91       	pop	r25
  f8:	8f 91       	pop	r24
  fa:	5f 91       	pop	r21
  fc:	4f 91       	pop	r20
  fe:	3f 91       	pop	r19
 100:	2f 91       	pop	r18
 102:	0f 90       	pop	r0
 104:	0f be       	out	0x3f, r0	; 63
 106:	0f 90       	pop	r0
 108:	1f 90       	pop	r1
 10a:	18 95       	reti
    packet_head++;
    if (packet_head >= PACKET_SIZE)
        packet_head = 0;

    if (packet_buffer[packet_head] == PACKET_HEADER) {
        if (packet_checksum == 0) {
 10c:	33 23       	and	r19, r19
 10e:	79 f7       	brne	.-34     	; 0xee <__vector_18+0x5e>
            uint16_t i;
            uint16_t num = PACKET_SIZE-packet_head;
 110:	44 e8       	ldi	r20, 0x84	; 132
 112:	50 e0       	ldi	r21, 0x00	; 0
 114:	4e 1b       	sub	r20, r30
 116:	5f 0b       	sbc	r21, r31
            for (i = 0; i < num; i++)
 118:	01 f1       	breq	.+64     	; 0x15a <__vector_18+0xca>
 11a:	e8 e9       	ldi	r30, 0x98	; 152
 11c:	f1 e0       	ldi	r31, 0x01	; 1
 11e:	9a 01       	movw	r18, r20
 120:	2e 0f       	add	r18, r30
 122:	3f 1f       	adc	r19, r31
                new_packet[i] = packet_buffer[i+packet_head];
 124:	8d 91       	ld	r24, X+
 126:	81 93       	st	Z+, r24

    if (packet_buffer[packet_head] == PACKET_HEADER) {
        if (packet_checksum == 0) {
            uint16_t i;
            uint16_t num = PACKET_SIZE-packet_head;
            for (i = 0; i < num; i++)
 128:	e2 17       	cp	r30, r18
 12a:	f3 07       	cpc	r31, r19
 12c:	d9 f7       	brne	.-10     	; 0x124 <__vector_18+0x94>
                new_packet[i] = packet_buffer[i+packet_head];
            for (i = num; i < PACKET_SIZE; i++)
 12e:	44 38       	cpi	r20, 0x84	; 132
 130:	51 05       	cpc	r21, r1
 132:	58 f4       	brcc	.+22     	; 0x14a <__vector_18+0xba>

    if (packet_buffer[packet_head] == PACKET_HEADER) {
        if (packet_checksum == 0) {
            uint16_t i;
            uint16_t num = PACKET_SIZE-packet_head;
            for (i = 0; i < num; i++)
 134:	a5 e0       	ldi	r26, 0x05	; 5
 136:	b1 e0       	ldi	r27, 0x01	; 1
 138:	f9 01       	movw	r30, r18
 13a:	9a 01       	movw	r18, r20
                new_packet[i] = packet_buffer[i+packet_head];
            for (i = num; i < PACKET_SIZE; i++)
                new_packet[i] = packet_buffer[i-num];
 13c:	8d 91       	ld	r24, X+
 13e:	81 93       	st	Z+, r24
        if (packet_checksum == 0) {
            uint16_t i;
            uint16_t num = PACKET_SIZE-packet_head;
            for (i = 0; i < num; i++)
                new_packet[i] = packet_buffer[i+packet_head];
            for (i = num; i < PACKET_SIZE; i++)
 140:	2f 5f       	subi	r18, 0xFF	; 255
 142:	3f 4f       	sbci	r19, 0xFF	; 255
 144:	24 38       	cpi	r18, 0x84	; 132
 146:	31 05       	cpc	r19, r1
 148:	c8 f3       	brcs	.-14     	; 0x13c <__vector_18+0xac>
                new_packet[i] = packet_buffer[i-num];
            has_new_packet = 1;
 14a:	81 e0       	ldi	r24, 0x01	; 1
 14c:	80 93 02 01 	sts	0x0102, r24
            packet_type = new_packet[1];
 150:	80 91 99 01 	lds	r24, 0x0199
 154:	80 93 97 01 	sts	0x0197, r24
 158:	ca cf       	rjmp	.-108    	; 0xee <__vector_18+0x5e>
 15a:	28 e9       	ldi	r18, 0x98	; 152
 15c:	31 e0       	ldi	r19, 0x01	; 1
 15e:	ea cf       	rjmp	.-44     	; 0x134 <__vector_18+0xa4>

00000160 <main>:
#define led_port PORTB
#define led_ddr DDRB
#define led_mask (1<<1)
#endif

int main() {
 160:	ef 92       	push	r14
 162:	ff 92       	push	r15
 164:	1f 93       	push	r17
 166:	cf 93       	push	r28
 168:	df 93       	push	r29
    cli();
 16a:	f8 94       	cli
    // Set port outputs
    ir_ddr |= ir_mask;
 16c:	21 9a       	sbi	0x04, 1	; 4
    led_ddr |= led_mask;
 16e:	25 9a       	sbi	0x04, 5	; 4
    // Turn off all leds
    led_port &= ~led_mask;
 170:	2d 98       	cbi	0x05, 5	; 5
    ir_port &= ~ir_mask;
 172:	29 98       	cbi	0x05, 1	; 5
    // turn off analog comparator (to avoid detecting collisions)
    ACSR |= (1<<ACD);
 174:	80 b7       	in	r24, 0x30	; 48
 176:	80 68       	ori	r24, 0x80	; 128
 178:	80 bf       	out	0x30, r24	; 48
    CLKPR = 1;
#endif

#define BAUD 38400
#include <util/setbaud.h>
    UBRR0 = UBRR_VALUE;
 17a:	8c e0       	ldi	r24, 0x0C	; 12
 17c:	90 e0       	ldi	r25, 0x00	; 0
 17e:	90 93 c5 00 	sts	0x00C5, r25
 182:	80 93 c4 00 	sts	0x00C4, r24
#if USE_2X
    UCSR0A |= (1<<U2X0);
#else
    UCSR0A &= ~(1<<U2X0);
 186:	80 91 c0 00 	lds	r24, 0x00C0
 18a:	8d 7f       	andi	r24, 0xFD	; 253
 18c:	80 93 c0 00 	sts	0x00C0, r24
#endif
    UCSR0C |= (1<<UCSZ01)|(1<<UCSZ00);              // No parity, 8 bits comm, 1 stop bit
 190:	80 91 c2 00 	lds	r24, 0x00C2
 194:	86 60       	ori	r24, 0x06	; 6
 196:	80 93 c2 00 	sts	0x00C2, r24
    UCSR0B |= (1<<RXCIE0)|(1<<RXEN0)|(1<<TXEN0);    // Enable reception, transmission, and reception interrupts
 19a:	80 91 c1 00 	lds	r24, 0x00C1
 19e:	88 69       	ori	r24, 0x98	; 152
 1a0:	80 93 c1 00 	sts	0x00C1, r24
    sei();
 1a4:	78 94       	sei

    tx_mask = ir_mask;
 1a6:	82 e0       	ldi	r24, 0x02	; 2
 1a8:	80 93 03 01 	sts	0x0103, r24
    bootmsg = (bootmsg_t*)msg.data;
 1ac:	8b e8       	ldi	r24, 0x8B	; 139
 1ae:	e8 2e       	mov	r14, r24
 1b0:	81 e0       	ldi	r24, 0x01	; 1
 1b2:	f8 2e       	mov	r15, r24
 1b4:	f0 92 8a 01 	sts	0x018A, r15
 1b8:	e0 92 89 01 	sts	0x0189, r14
    gpsmsg = (gpsmsg_t*)msg.data;
 1bc:	f0 92 1f 02 	sts	0x021F, r15
 1c0:	e0 92 1e 02 	sts	0x021E, r14
    rawmsg = (uint8_t*)&msg;
 1c4:	f0 92 1d 02 	sts	0x021D, r15
 1c8:	e0 92 1c 02 	sts	0x021C, r14
 1cc:	65 e0       	ldi	r22, 0x05	; 5
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
 1ce:	48 ec       	ldi	r20, 0xC8	; 200
 1d0:	50 e0       	ldi	r21, 0x00	; 0

    // Use LEDs to flash power on indicator signal.
    uint8_t i;
    for (i=0; i<5; i++) {
        led_port |= led_mask;
 1d2:	2d 9a       	sbi	0x05, 5	; 5
 1d4:	20 e0       	ldi	r18, 0x00	; 0
 1d6:	30 e0       	ldi	r19, 0x00	; 0
 1d8:	ca 01       	movw	r24, r20
 1da:	01 97       	sbiw	r24, 0x01	; 1
 1dc:	f1 f7       	brne	.-4      	; 0x1da <main+0x7a>
 1de:	2f 5f       	subi	r18, 0xFF	; 255
 1e0:	3f 4f       	sbci	r19, 0xFF	; 255
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 1e2:	87 e0       	ldi	r24, 0x07	; 7
 1e4:	20 3d       	cpi	r18, 0xD0	; 208
 1e6:	38 07       	cpc	r19, r24
 1e8:	b9 f7       	brne	.-18     	; 0x1d8 <main+0x78>
        _delay_ms(200);
        led_port &= ~led_mask;
 1ea:	2d 98       	cbi	0x05, 5	; 5
 1ec:	20 e0       	ldi	r18, 0x00	; 0
 1ee:	30 e0       	ldi	r19, 0x00	; 0
 1f0:	ca 01       	movw	r24, r20
 1f2:	01 97       	sbiw	r24, 0x01	; 1
 1f4:	f1 f7       	brne	.-4      	; 0x1f2 <main+0x92>
 1f6:	2f 5f       	subi	r18, 0xFF	; 255
 1f8:	3f 4f       	sbci	r19, 0xFF	; 255
 1fa:	e7 e0       	ldi	r30, 0x07	; 7
 1fc:	20 3d       	cpi	r18, 0xD0	; 208
 1fe:	3e 07       	cpc	r19, r30
 200:	b9 f7       	brne	.-18     	; 0x1f0 <main+0x90>
 202:	61 50       	subi	r22, 0x01	; 1
    gpsmsg = (gpsmsg_t*)msg.data;
    rawmsg = (uint8_t*)&msg;

    // Use LEDs to flash power on indicator signal.
    uint8_t i;
    for (i=0; i<5; i++) {
 204:	31 f7       	brne	.-52     	; 0x1d2 <main+0x72>
        led_port &= ~led_mask;
        _delay_ms(200);
    }

    while(1) {
        if (has_new_packet) {
 206:	80 91 02 01 	lds	r24, 0x0102
 20a:	88 23       	and	r24, r24
 20c:	e1 f3       	breq	.-8      	; 0x206 <main+0xa6>
            has_new_packet = 0;
 20e:	10 92 02 01 	sts	0x0102, r1
            switch(packet_type) {
 212:	80 91 97 01 	lds	r24, 0x0197
 216:	83 30       	cpi	r24, 0x03	; 3
 218:	09 f4       	brne	.+2      	; 0x21c <main+0xbc>
 21a:	7a c4       	rjmp	.+2292   	; 0xb10 <__stack+0x211>
 21c:	84 30       	cpi	r24, 0x04	; 4
 21e:	08 f0       	brcs	.+2      	; 0x222 <main+0xc2>
 220:	70 c0       	rjmp	.+224    	; 0x302 <main+0x1a2>
 222:	81 30       	cpi	r24, 0x01	; 1
 224:	09 f4       	brne	.+2      	; 0x228 <main+0xc8>
 226:	62 c4       	rjmp	.+2244   	; 0xaec <__stack+0x1ed>
 228:	82 30       	cpi	r24, 0x02	; 2
 22a:	69 f7       	brne	.-38     	; 0x206 <main+0xa6>
                    led_port &= ~led_mask;
                }
                break;
            case PACKET_FORWARDMSG:
                for (i = 0; i<sizeof(message_t)-sizeof(msg.crc); i++)
                    rawmsg[i] = new_packet[i+2];
 22c:	e0 91 1c 02 	lds	r30, 0x021C
 230:	f0 91 1d 02 	lds	r31, 0x021D
 234:	80 91 9a 01 	lds	r24, 0x019A
 238:	80 83       	st	Z, r24
 23a:	e0 91 1c 02 	lds	r30, 0x021C
 23e:	f0 91 1d 02 	lds	r31, 0x021D
 242:	80 91 9b 01 	lds	r24, 0x019B
 246:	81 83       	std	Z+1, r24	; 0x01
 248:	e0 91 1c 02 	lds	r30, 0x021C
 24c:	f0 91 1d 02 	lds	r31, 0x021D
 250:	80 91 9c 01 	lds	r24, 0x019C
 254:	82 83       	std	Z+2, r24	; 0x02
 256:	e0 91 1c 02 	lds	r30, 0x021C
 25a:	f0 91 1d 02 	lds	r31, 0x021D
 25e:	80 91 9d 01 	lds	r24, 0x019D
 262:	83 83       	std	Z+3, r24	; 0x03
 264:	e0 91 1c 02 	lds	r30, 0x021C
 268:	f0 91 1d 02 	lds	r31, 0x021D
 26c:	80 91 9e 01 	lds	r24, 0x019E
 270:	84 83       	std	Z+4, r24	; 0x04
 272:	e0 91 1c 02 	lds	r30, 0x021C
 276:	f0 91 1d 02 	lds	r31, 0x021D
 27a:	80 91 9f 01 	lds	r24, 0x019F
 27e:	85 83       	std	Z+5, r24	; 0x05
 280:	e0 91 1c 02 	lds	r30, 0x021C
 284:	f0 91 1d 02 	lds	r31, 0x021D
 288:	80 91 a0 01 	lds	r24, 0x01A0
 28c:	86 83       	std	Z+6, r24	; 0x06
 28e:	e0 91 1c 02 	lds	r30, 0x021C
 292:	f0 91 1d 02 	lds	r31, 0x021D
 296:	80 91 a1 01 	lds	r24, 0x01A1
 29a:	87 83       	std	Z+7, r24	; 0x07
 29c:	e0 91 1c 02 	lds	r30, 0x021C
 2a0:	f0 91 1d 02 	lds	r31, 0x021D
 2a4:	80 91 a2 01 	lds	r24, 0x01A2
 2a8:	80 87       	std	Z+8, r24	; 0x08
 2aa:	e0 91 1c 02 	lds	r30, 0x021C
 2ae:	f0 91 1d 02 	lds	r31, 0x021D
 2b2:	80 91 a3 01 	lds	r24, 0x01A3
 2b6:	81 87       	std	Z+9, r24	; 0x09
                msg.crc = message_crc(&msg);
 2b8:	8b e8       	ldi	r24, 0x8B	; 139
 2ba:	91 e0       	ldi	r25, 0x01	; 1
 2bc:	0e 94 00 06 	call	0xc00	; 0xc00 <message_crc>
 2c0:	90 93 96 01 	sts	0x0196, r25
 2c4:	80 93 95 01 	sts	0x0195, r24
                while(!has_new_packet) {
 2c8:	80 91 02 01 	lds	r24, 0x0102
 2cc:	88 23       	and	r24, r24
 2ce:	09 f0       	breq	.+2      	; 0x2d2 <main+0x172>
 2d0:	9a cf       	rjmp	.-204    	; 0x206 <main+0xa6>
 2d2:	c0 e7       	ldi	r28, 0x70	; 112
 2d4:	d7 e1       	ldi	r29, 0x17	; 23
                    message_send(&msg);
 2d6:	8b e8       	ldi	r24, 0x8B	; 139
 2d8:	91 e0       	ldi	r25, 0x01	; 1
 2da:	0e 94 b9 06 	call	0xd72	; 0xd72 <message_send>
                    led_port |= led_mask;
 2de:	2d 9a       	sbi	0x05, 5	; 5
 2e0:	ce 01       	movw	r24, r28
 2e2:	01 97       	sbiw	r24, 0x01	; 1
 2e4:	f1 f7       	brne	.-4      	; 0x2e2 <main+0x182>
                    _delay_ms(3);
                    led_port &= ~led_mask;
 2e6:	2d 98       	cbi	0x05, 5	; 5
 2e8:	ce 01       	movw	r24, r28
 2ea:	01 97       	sbiw	r24, 0x01	; 1
 2ec:	f1 f7       	brne	.-4      	; 0x2ea <main+0x18a>
                break;
            case PACKET_FORWARDMSG:
                for (i = 0; i<sizeof(message_t)-sizeof(msg.crc); i++)
                    rawmsg[i] = new_packet[i+2];
                msg.crc = message_crc(&msg);
                while(!has_new_packet) {
 2ee:	80 91 02 01 	lds	r24, 0x0102
 2f2:	88 23       	and	r24, r24
 2f4:	81 f3       	breq	.-32     	; 0x2d6 <main+0x176>
        led_port &= ~led_mask;
        _delay_ms(200);
    }

    while(1) {
        if (has_new_packet) {
 2f6:	80 91 02 01 	lds	r24, 0x0102
 2fa:	88 23       	and	r24, r24
 2fc:	09 f4       	brne	.+2      	; 0x300 <main+0x1a0>
 2fe:	83 cf       	rjmp	.-250    	; 0x206 <main+0xa6>
 300:	86 cf       	rjmp	.-244    	; 0x20e <main+0xae>
            has_new_packet = 0;
            switch(packet_type) {
 302:	85 30       	cpi	r24, 0x05	; 5
 304:	09 f4       	brne	.+2      	; 0x308 <main+0x1a8>
 306:	a8 c0       	rjmp	.+336    	; 0x458 <main+0x2f8>
 308:	85 30       	cpi	r24, 0x05	; 5
 30a:	08 f4       	brcc	.+2      	; 0x30e <main+0x1ae>
 30c:	64 c0       	rjmp	.+200    	; 0x3d6 <main+0x276>
 30e:	86 30       	cpi	r24, 0x06	; 6
 310:	09 f0       	breq	.+2      	; 0x314 <main+0x1b4>
 312:	79 cf       	rjmp	.-270    	; 0x206 <main+0xa6>
                    _delay_ms(3);
                }
                break;
            case PACKET_FORWARDMSGSINGLE:
                for (i = 0; i<sizeof(message_t)-sizeof(msg.crc); i++)
                    rawmsg[i] = new_packet[i+2];
 314:	e0 91 1c 02 	lds	r30, 0x021C
 318:	f0 91 1d 02 	lds	r31, 0x021D
 31c:	80 91 9a 01 	lds	r24, 0x019A
 320:	80 83       	st	Z, r24
 322:	e0 91 1c 02 	lds	r30, 0x021C
 326:	f0 91 1d 02 	lds	r31, 0x021D
 32a:	80 91 9b 01 	lds	r24, 0x019B
 32e:	81 83       	std	Z+1, r24	; 0x01
 330:	e0 91 1c 02 	lds	r30, 0x021C
 334:	f0 91 1d 02 	lds	r31, 0x021D
 338:	80 91 9c 01 	lds	r24, 0x019C
 33c:	82 83       	std	Z+2, r24	; 0x02
 33e:	e0 91 1c 02 	lds	r30, 0x021C
 342:	f0 91 1d 02 	lds	r31, 0x021D
 346:	80 91 9d 01 	lds	r24, 0x019D
 34a:	83 83       	std	Z+3, r24	; 0x03
 34c:	e0 91 1c 02 	lds	r30, 0x021C
 350:	f0 91 1d 02 	lds	r31, 0x021D
 354:	80 91 9e 01 	lds	r24, 0x019E
 358:	84 83       	std	Z+4, r24	; 0x04
 35a:	e0 91 1c 02 	lds	r30, 0x021C
 35e:	f0 91 1d 02 	lds	r31, 0x021D
 362:	80 91 9f 01 	lds	r24, 0x019F
 366:	85 83       	std	Z+5, r24	; 0x05
 368:	e0 91 1c 02 	lds	r30, 0x021C
 36c:	f0 91 1d 02 	lds	r31, 0x021D
 370:	80 91 a0 01 	lds	r24, 0x01A0
 374:	86 83       	std	Z+6, r24	; 0x06
 376:	e0 91 1c 02 	lds	r30, 0x021C
 37a:	f0 91 1d 02 	lds	r31, 0x021D
 37e:	80 91 a1 01 	lds	r24, 0x01A1
 382:	87 83       	std	Z+7, r24	; 0x07
 384:	e0 91 1c 02 	lds	r30, 0x021C
 388:	f0 91 1d 02 	lds	r31, 0x021D
 38c:	80 91 a2 01 	lds	r24, 0x01A2
 390:	80 87       	std	Z+8, r24	; 0x08
 392:	e0 91 1c 02 	lds	r30, 0x021C
 396:	f0 91 1d 02 	lds	r31, 0x021D
 39a:	80 91 a3 01 	lds	r24, 0x01A3
 39e:	81 87       	std	Z+9, r24	; 0x09
                msg.crc = message_crc(&msg);
 3a0:	8b e8       	ldi	r24, 0x8B	; 139
 3a2:	91 e0       	ldi	r25, 0x01	; 1
 3a4:	0e 94 00 06 	call	0xc00	; 0xc00 <message_crc>
 3a8:	90 93 96 01 	sts	0x0196, r25
 3ac:	80 93 95 01 	sts	0x0195, r24
                message_send(&msg);
 3b0:	8b e8       	ldi	r24, 0x8B	; 139
 3b2:	91 e0       	ldi	r25, 0x01	; 1
 3b4:	0e 94 b9 06 	call	0xd72	; 0xd72 <message_send>
                led_port |= led_mask;
 3b8:	2d 9a       	sbi	0x05, 5	; 5
 3ba:	80 e7       	ldi	r24, 0x70	; 112
 3bc:	97 e1       	ldi	r25, 0x17	; 23
 3be:	fc 01       	movw	r30, r24
 3c0:	31 97       	sbiw	r30, 0x01	; 1
 3c2:	f1 f7       	brne	.-4      	; 0x3c0 <main+0x260>
                _delay_ms(3);
                led_port &= ~led_mask;
 3c4:	2d 98       	cbi	0x05, 5	; 5
 3c6:	01 97       	sbiw	r24, 0x01	; 1
 3c8:	f1 f7       	brne	.-4      	; 0x3c6 <main+0x266>
        led_port &= ~led_mask;
        _delay_ms(200);
    }

    while(1) {
        if (has_new_packet) {
 3ca:	80 91 02 01 	lds	r24, 0x0102
 3ce:	88 23       	and	r24, r24
 3d0:	09 f4       	brne	.+2      	; 0x3d4 <main+0x274>
 3d2:	19 cf       	rjmp	.-462    	; 0x206 <main+0xa6>
 3d4:	1c cf       	rjmp	.-456    	; 0x20e <main+0xae>
                    led_port &= ~led_mask;
                    _delay_ms(3);
                }
                break;
            case PACKET_BOOTPAGE:
                msg.type = BOOTPGM_PAGE;
 3d6:	81 e8       	ldi	r24, 0x81	; 129
 3d8:	80 93 94 01 	sts	0x0194, r24
                bootmsg->page_address = new_packet[2];
 3dc:	e0 91 89 01 	lds	r30, 0x0189
 3e0:	f0 91 8a 01 	lds	r31, 0x018A
 3e4:	80 91 9a 01 	lds	r24, 0x019A
 3e8:	80 83       	st	Z, r24
                bootmsg->unused = 0;
 3ea:	10 86       	std	Z+8, r1	; 0x08
                cli();
 3ec:	f8 94       	cli
 3ee:	cb e9       	ldi	r28, 0x9B	; 155
 3f0:	d1 e0       	ldi	r29, 0x01	; 1
 3f2:	10 e0       	ldi	r17, 0x00	; 0
                for (i = 0; i<SPM_PAGESIZE && !has_new_packet; i+=6) {
 3f4:	80 91 02 01 	lds	r24, 0x0102
 3f8:	88 23       	and	r24, r24
 3fa:	f1 f4       	brne	.+60     	; 0x438 <main+0x2d8>
                    bootmsg->page_offset = i/2;
 3fc:	e0 91 89 01 	lds	r30, 0x0189
 400:	f0 91 8a 01 	lds	r31, 0x018A
 404:	81 2f       	mov	r24, r17
 406:	86 95       	lsr	r24
 408:	81 83       	std	Z+1, r24	; 0x01
                    memcpy(&(bootmsg->word1), new_packet+3+i, 6);
 40a:	32 96       	adiw	r30, 0x02	; 2
 40c:	de 01       	movw	r26, r28
 40e:	86 e0       	ldi	r24, 0x06	; 6
 410:	0d 90       	ld	r0, X+
 412:	01 92       	st	Z+, r0
 414:	81 50       	subi	r24, 0x01	; 1
 416:	e1 f7       	brne	.-8      	; 0x410 <main+0x2b0>
                    msg.crc = message_crc(&msg);
 418:	8b e8       	ldi	r24, 0x8B	; 139
 41a:	91 e0       	ldi	r25, 0x01	; 1
 41c:	0e 94 00 06 	call	0xc00	; 0xc00 <message_crc>
 420:	90 93 96 01 	sts	0x0196, r25
 424:	80 93 95 01 	sts	0x0195, r24
                    message_send(&msg);
 428:	8b e8       	ldi	r24, 0x8B	; 139
 42a:	91 e0       	ldi	r25, 0x01	; 1
 42c:	0e 94 b9 06 	call	0xd72	; 0xd72 <message_send>
            case PACKET_BOOTPAGE:
                msg.type = BOOTPGM_PAGE;
                bootmsg->page_address = new_packet[2];
                bootmsg->unused = 0;
                cli();
                for (i = 0; i<SPM_PAGESIZE && !has_new_packet; i+=6) {
 430:	1a 5f       	subi	r17, 0xFA	; 250
 432:	26 96       	adiw	r28, 0x06	; 6
 434:	14 38       	cpi	r17, 0x84	; 132
 436:	f1 f6       	brne	.-68     	; 0x3f4 <main+0x294>
                    bootmsg->page_offset = i/2;
                    memcpy(&(bootmsg->word1), new_packet+3+i, 6);
                    msg.crc = message_crc(&msg);
                    message_send(&msg);
                }
                sei();
 438:	78 94       	sei
                    msg.crc = message_crc(&msg);
                    message_send(&msg);
                    _delay_us(50);
                }
                sei();
                led_port |= led_mask;
 43a:	2d 9a       	sbi	0x05, 5	; 5
 43c:	80 e2       	ldi	r24, 0x20	; 32
 43e:	9e e4       	ldi	r25, 0x4E	; 78
 440:	fc 01       	movw	r30, r24
 442:	31 97       	sbiw	r30, 0x01	; 1
 444:	f1 f7       	brne	.-4      	; 0x442 <main+0x2e2>
                _delay_ms(10);
                led_port &= ~led_mask;
 446:	2d 98       	cbi	0x05, 5	; 5
 448:	01 97       	sbiw	r24, 0x01	; 1
 44a:	f1 f7       	brne	.-4      	; 0x448 <main+0x2e8>
        led_port &= ~led_mask;
        _delay_ms(200);
    }

    while(1) {
        if (has_new_packet) {
 44c:	80 91 02 01 	lds	r24, 0x0102
 450:	88 23       	and	r24, r24
 452:	09 f4       	brne	.+2      	; 0x456 <main+0x2f6>
 454:	d8 ce       	rjmp	.-592    	; 0x206 <main+0xa6>
 456:	db ce       	rjmp	.-586    	; 0x20e <main+0xae>
                led_port &= ~led_mask;
                _delay_ms(10);
                break;
#define GPS_MSGSIZE 8
            case PACKET_GPSFRAME:
                memset(&msg, 0, sizeof(message_t)-sizeof(msg.crc));
 458:	8a e0       	ldi	r24, 0x0A	; 10
 45a:	f7 01       	movw	r30, r14
 45c:	11 92       	st	Z+, r1
 45e:	8a 95       	dec	r24
 460:	e9 f7       	brne	.-6      	; 0x45c <main+0x2fc>
                msg.type = GPS;
 462:	81 e0       	ldi	r24, 0x01	; 1
 464:	80 93 94 01 	sts	0x0194, r24
                cli();
 468:	f8 94       	cli
                for (i = 2; i<PACKET_SIZE-GPS_MSGSIZE; i += GPS_MSGSIZE) {
                    memcpy(gpsmsg, new_packet+i, GPS_MSGSIZE);
 46a:	20 91 1e 02 	lds	r18, 0x021E
 46e:	30 91 1f 02 	lds	r19, 0x021F
 472:	c9 01       	movw	r24, r18
 474:	dc 01       	movw	r26, r24
 476:	ea e9       	ldi	r30, 0x9A	; 154
 478:	f1 e0       	ldi	r31, 0x01	; 1
 47a:	88 e0       	ldi	r24, 0x08	; 8
 47c:	01 90       	ld	r0, Z+
 47e:	0d 92       	st	X+, r0
 480:	81 50       	subi	r24, 0x01	; 1
 482:	e1 f7       	brne	.-8      	; 0x47c <main+0x31c>
                    if (gpsmsg->id == 0 && gpsmsg->x == 0 && gpsmsg->y == 0 && gpsmsg->theta == 0 && gpsmsg->unused == 0)
 484:	e0 91 1e 02 	lds	r30, 0x021E
 488:	f0 91 1f 02 	lds	r31, 0x021F
 48c:	80 81       	ld	r24, Z
 48e:	91 81       	ldd	r25, Z+1	; 0x01
 490:	89 2b       	or	r24, r25
 492:	81 f4       	brne	.+32     	; 0x4b4 <main+0x354>
 494:	82 81       	ldd	r24, Z+2	; 0x02
 496:	93 81       	ldd	r25, Z+3	; 0x03
 498:	89 2b       	or	r24, r25
 49a:	61 f4       	brne	.+24     	; 0x4b4 <main+0x354>
 49c:	84 81       	ldd	r24, Z+4	; 0x04
 49e:	95 81       	ldd	r25, Z+5	; 0x05
 4a0:	89 2b       	or	r24, r25
 4a2:	41 f4       	brne	.+16     	; 0x4b4 <main+0x354>
 4a4:	86 81       	ldd	r24, Z+6	; 0x06
 4a6:	88 23       	and	r24, r24
 4a8:	29 f4       	brne	.+10     	; 0x4b4 <main+0x354>
 4aa:	87 81       	ldd	r24, Z+7	; 0x07
 4ac:	90 85       	ldd	r25, Z+8	; 0x08
 4ae:	89 2b       	or	r24, r25
 4b0:	09 f4       	brne	.+2      	; 0x4b4 <main+0x354>
 4b2:	1a c3       	rjmp	.+1588   	; 0xae8 <__stack+0x1e9>
                        break;
                    msg.crc = message_crc(&msg);
 4b4:	8b e8       	ldi	r24, 0x8B	; 139
 4b6:	91 e0       	ldi	r25, 0x01	; 1
 4b8:	0e 94 00 06 	call	0xc00	; 0xc00 <message_crc>
 4bc:	90 93 96 01 	sts	0x0196, r25
 4c0:	80 93 95 01 	sts	0x0195, r24
                    message_send(&msg);
 4c4:	8b e8       	ldi	r24, 0x8B	; 139
 4c6:	91 e0       	ldi	r25, 0x01	; 1
 4c8:	0e 94 b9 06 	call	0xd72	; 0xd72 <message_send>
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
 4cc:	85 e8       	ldi	r24, 0x85	; 133
 4ce:	8a 95       	dec	r24
 4d0:	f1 f7       	brne	.-4      	; 0x4ce <main+0x36e>
            case PACKET_GPSFRAME:
                memset(&msg, 0, sizeof(message_t)-sizeof(msg.crc));
                msg.type = GPS;
                cli();
                for (i = 2; i<PACKET_SIZE-GPS_MSGSIZE; i += GPS_MSGSIZE) {
                    memcpy(gpsmsg, new_packet+i, GPS_MSGSIZE);
 4d2:	80 91 1e 02 	lds	r24, 0x021E
 4d6:	90 91 1f 02 	lds	r25, 0x021F
 4da:	9c 01       	movw	r18, r24
 4dc:	d9 01       	movw	r26, r18
 4de:	e2 ea       	ldi	r30, 0xA2	; 162
 4e0:	f1 e0       	ldi	r31, 0x01	; 1
 4e2:	88 e0       	ldi	r24, 0x08	; 8
 4e4:	01 90       	ld	r0, Z+
 4e6:	0d 92       	st	X+, r0
 4e8:	81 50       	subi	r24, 0x01	; 1
 4ea:	e1 f7       	brne	.-8      	; 0x4e4 <main+0x384>
                    if (gpsmsg->id == 0 && gpsmsg->x == 0 && gpsmsg->y == 0 && gpsmsg->theta == 0 && gpsmsg->unused == 0)
 4ec:	e0 91 1e 02 	lds	r30, 0x021E
 4f0:	f0 91 1f 02 	lds	r31, 0x021F
 4f4:	80 81       	ld	r24, Z
 4f6:	91 81       	ldd	r25, Z+1	; 0x01
 4f8:	89 2b       	or	r24, r25
 4fa:	81 f4       	brne	.+32     	; 0x51c <main+0x3bc>
 4fc:	82 81       	ldd	r24, Z+2	; 0x02
 4fe:	93 81       	ldd	r25, Z+3	; 0x03
 500:	89 2b       	or	r24, r25
 502:	61 f4       	brne	.+24     	; 0x51c <main+0x3bc>
 504:	84 81       	ldd	r24, Z+4	; 0x04
 506:	95 81       	ldd	r25, Z+5	; 0x05
 508:	89 2b       	or	r24, r25
 50a:	41 f4       	brne	.+16     	; 0x51c <main+0x3bc>
 50c:	86 81       	ldd	r24, Z+6	; 0x06
 50e:	88 23       	and	r24, r24
 510:	29 f4       	brne	.+10     	; 0x51c <main+0x3bc>
 512:	87 81       	ldd	r24, Z+7	; 0x07
 514:	90 85       	ldd	r25, Z+8	; 0x08
 516:	89 2b       	or	r24, r25
 518:	09 f4       	brne	.+2      	; 0x51c <main+0x3bc>
 51a:	e6 c2       	rjmp	.+1484   	; 0xae8 <__stack+0x1e9>
                        break;
                    msg.crc = message_crc(&msg);
 51c:	8b e8       	ldi	r24, 0x8B	; 139
 51e:	91 e0       	ldi	r25, 0x01	; 1
 520:	0e 94 00 06 	call	0xc00	; 0xc00 <message_crc>
 524:	90 93 96 01 	sts	0x0196, r25
 528:	80 93 95 01 	sts	0x0195, r24
                    message_send(&msg);
 52c:	8b e8       	ldi	r24, 0x8B	; 139
 52e:	91 e0       	ldi	r25, 0x01	; 1
 530:	0e 94 b9 06 	call	0xd72	; 0xd72 <message_send>
 534:	85 e8       	ldi	r24, 0x85	; 133
 536:	8a 95       	dec	r24
 538:	f1 f7       	brne	.-4      	; 0x536 <main+0x3d6>
            case PACKET_GPSFRAME:
                memset(&msg, 0, sizeof(message_t)-sizeof(msg.crc));
                msg.type = GPS;
                cli();
                for (i = 2; i<PACKET_SIZE-GPS_MSGSIZE; i += GPS_MSGSIZE) {
                    memcpy(gpsmsg, new_packet+i, GPS_MSGSIZE);
 53a:	80 91 1e 02 	lds	r24, 0x021E
 53e:	90 91 1f 02 	lds	r25, 0x021F
 542:	9c 01       	movw	r18, r24
 544:	d9 01       	movw	r26, r18
 546:	ea ea       	ldi	r30, 0xAA	; 170
 548:	f1 e0       	ldi	r31, 0x01	; 1
 54a:	88 e0       	ldi	r24, 0x08	; 8
 54c:	01 90       	ld	r0, Z+
 54e:	0d 92       	st	X+, r0
 550:	81 50       	subi	r24, 0x01	; 1
 552:	e1 f7       	brne	.-8      	; 0x54c <main+0x3ec>
                    if (gpsmsg->id == 0 && gpsmsg->x == 0 && gpsmsg->y == 0 && gpsmsg->theta == 0 && gpsmsg->unused == 0)
 554:	e0 91 1e 02 	lds	r30, 0x021E
 558:	f0 91 1f 02 	lds	r31, 0x021F
 55c:	80 81       	ld	r24, Z
 55e:	91 81       	ldd	r25, Z+1	; 0x01
 560:	89 2b       	or	r24, r25
 562:	81 f4       	brne	.+32     	; 0x584 <main+0x424>
 564:	82 81       	ldd	r24, Z+2	; 0x02
 566:	93 81       	ldd	r25, Z+3	; 0x03
 568:	89 2b       	or	r24, r25
 56a:	61 f4       	brne	.+24     	; 0x584 <main+0x424>
 56c:	84 81       	ldd	r24, Z+4	; 0x04
 56e:	95 81       	ldd	r25, Z+5	; 0x05
 570:	89 2b       	or	r24, r25
 572:	41 f4       	brne	.+16     	; 0x584 <main+0x424>
 574:	86 81       	ldd	r24, Z+6	; 0x06
 576:	88 23       	and	r24, r24
 578:	29 f4       	brne	.+10     	; 0x584 <main+0x424>
 57a:	87 81       	ldd	r24, Z+7	; 0x07
 57c:	90 85       	ldd	r25, Z+8	; 0x08
 57e:	89 2b       	or	r24, r25
 580:	09 f4       	brne	.+2      	; 0x584 <main+0x424>
 582:	b2 c2       	rjmp	.+1380   	; 0xae8 <__stack+0x1e9>
                        break;
                    msg.crc = message_crc(&msg);
 584:	8b e8       	ldi	r24, 0x8B	; 139
 586:	91 e0       	ldi	r25, 0x01	; 1
 588:	0e 94 00 06 	call	0xc00	; 0xc00 <message_crc>
 58c:	90 93 96 01 	sts	0x0196, r25
 590:	80 93 95 01 	sts	0x0195, r24
                    message_send(&msg);
 594:	8b e8       	ldi	r24, 0x8B	; 139
 596:	91 e0       	ldi	r25, 0x01	; 1
 598:	0e 94 b9 06 	call	0xd72	; 0xd72 <message_send>
 59c:	85 e8       	ldi	r24, 0x85	; 133
 59e:	8a 95       	dec	r24
 5a0:	f1 f7       	brne	.-4      	; 0x59e <main+0x43e>
            case PACKET_GPSFRAME:
                memset(&msg, 0, sizeof(message_t)-sizeof(msg.crc));
                msg.type = GPS;
                cli();
                for (i = 2; i<PACKET_SIZE-GPS_MSGSIZE; i += GPS_MSGSIZE) {
                    memcpy(gpsmsg, new_packet+i, GPS_MSGSIZE);
 5a2:	80 91 1e 02 	lds	r24, 0x021E
 5a6:	90 91 1f 02 	lds	r25, 0x021F
 5aa:	9c 01       	movw	r18, r24
 5ac:	d9 01       	movw	r26, r18
 5ae:	e2 eb       	ldi	r30, 0xB2	; 178
 5b0:	f1 e0       	ldi	r31, 0x01	; 1
 5b2:	88 e0       	ldi	r24, 0x08	; 8
 5b4:	01 90       	ld	r0, Z+
 5b6:	0d 92       	st	X+, r0
 5b8:	81 50       	subi	r24, 0x01	; 1
 5ba:	e1 f7       	brne	.-8      	; 0x5b4 <main+0x454>
                    if (gpsmsg->id == 0 && gpsmsg->x == 0 && gpsmsg->y == 0 && gpsmsg->theta == 0 && gpsmsg->unused == 0)
 5bc:	e0 91 1e 02 	lds	r30, 0x021E
 5c0:	f0 91 1f 02 	lds	r31, 0x021F
 5c4:	80 81       	ld	r24, Z
 5c6:	91 81       	ldd	r25, Z+1	; 0x01
 5c8:	89 2b       	or	r24, r25
 5ca:	81 f4       	brne	.+32     	; 0x5ec <main+0x48c>
 5cc:	82 81       	ldd	r24, Z+2	; 0x02
 5ce:	93 81       	ldd	r25, Z+3	; 0x03
 5d0:	89 2b       	or	r24, r25
 5d2:	61 f4       	brne	.+24     	; 0x5ec <main+0x48c>
 5d4:	84 81       	ldd	r24, Z+4	; 0x04
 5d6:	95 81       	ldd	r25, Z+5	; 0x05
 5d8:	89 2b       	or	r24, r25
 5da:	41 f4       	brne	.+16     	; 0x5ec <main+0x48c>
 5dc:	86 81       	ldd	r24, Z+6	; 0x06
 5de:	88 23       	and	r24, r24
 5e0:	29 f4       	brne	.+10     	; 0x5ec <main+0x48c>
 5e2:	87 81       	ldd	r24, Z+7	; 0x07
 5e4:	90 85       	ldd	r25, Z+8	; 0x08
 5e6:	89 2b       	or	r24, r25
 5e8:	09 f4       	brne	.+2      	; 0x5ec <main+0x48c>
 5ea:	7e c2       	rjmp	.+1276   	; 0xae8 <__stack+0x1e9>
                        break;
                    msg.crc = message_crc(&msg);
 5ec:	8b e8       	ldi	r24, 0x8B	; 139
 5ee:	91 e0       	ldi	r25, 0x01	; 1
 5f0:	0e 94 00 06 	call	0xc00	; 0xc00 <message_crc>
 5f4:	90 93 96 01 	sts	0x0196, r25
 5f8:	80 93 95 01 	sts	0x0195, r24
                    message_send(&msg);
 5fc:	8b e8       	ldi	r24, 0x8B	; 139
 5fe:	91 e0       	ldi	r25, 0x01	; 1
 600:	0e 94 b9 06 	call	0xd72	; 0xd72 <message_send>
 604:	85 e8       	ldi	r24, 0x85	; 133
 606:	8a 95       	dec	r24
 608:	f1 f7       	brne	.-4      	; 0x606 <main+0x4a6>
            case PACKET_GPSFRAME:
                memset(&msg, 0, sizeof(message_t)-sizeof(msg.crc));
                msg.type = GPS;
                cli();
                for (i = 2; i<PACKET_SIZE-GPS_MSGSIZE; i += GPS_MSGSIZE) {
                    memcpy(gpsmsg, new_packet+i, GPS_MSGSIZE);
 60a:	80 91 1e 02 	lds	r24, 0x021E
 60e:	90 91 1f 02 	lds	r25, 0x021F
 612:	9c 01       	movw	r18, r24
 614:	d9 01       	movw	r26, r18
 616:	ea eb       	ldi	r30, 0xBA	; 186
 618:	f1 e0       	ldi	r31, 0x01	; 1
 61a:	88 e0       	ldi	r24, 0x08	; 8
 61c:	01 90       	ld	r0, Z+
 61e:	0d 92       	st	X+, r0
 620:	81 50       	subi	r24, 0x01	; 1
 622:	e1 f7       	brne	.-8      	; 0x61c <main+0x4bc>
                    if (gpsmsg->id == 0 && gpsmsg->x == 0 && gpsmsg->y == 0 && gpsmsg->theta == 0 && gpsmsg->unused == 0)
 624:	e0 91 1e 02 	lds	r30, 0x021E
 628:	f0 91 1f 02 	lds	r31, 0x021F
 62c:	80 81       	ld	r24, Z
 62e:	91 81       	ldd	r25, Z+1	; 0x01
 630:	89 2b       	or	r24, r25
 632:	81 f4       	brne	.+32     	; 0x654 <main+0x4f4>
 634:	82 81       	ldd	r24, Z+2	; 0x02
 636:	93 81       	ldd	r25, Z+3	; 0x03
 638:	89 2b       	or	r24, r25
 63a:	61 f4       	brne	.+24     	; 0x654 <main+0x4f4>
 63c:	84 81       	ldd	r24, Z+4	; 0x04
 63e:	95 81       	ldd	r25, Z+5	; 0x05
 640:	89 2b       	or	r24, r25
 642:	41 f4       	brne	.+16     	; 0x654 <main+0x4f4>
 644:	86 81       	ldd	r24, Z+6	; 0x06
 646:	88 23       	and	r24, r24
 648:	29 f4       	brne	.+10     	; 0x654 <main+0x4f4>
 64a:	87 81       	ldd	r24, Z+7	; 0x07
 64c:	90 85       	ldd	r25, Z+8	; 0x08
 64e:	89 2b       	or	r24, r25
 650:	09 f4       	brne	.+2      	; 0x654 <main+0x4f4>
 652:	4a c2       	rjmp	.+1172   	; 0xae8 <__stack+0x1e9>
                        break;
                    msg.crc = message_crc(&msg);
 654:	8b e8       	ldi	r24, 0x8B	; 139
 656:	91 e0       	ldi	r25, 0x01	; 1
 658:	0e 94 00 06 	call	0xc00	; 0xc00 <message_crc>
 65c:	90 93 96 01 	sts	0x0196, r25
 660:	80 93 95 01 	sts	0x0195, r24
                    message_send(&msg);
 664:	8b e8       	ldi	r24, 0x8B	; 139
 666:	91 e0       	ldi	r25, 0x01	; 1
 668:	0e 94 b9 06 	call	0xd72	; 0xd72 <message_send>
 66c:	85 e8       	ldi	r24, 0x85	; 133
 66e:	8a 95       	dec	r24
 670:	f1 f7       	brne	.-4      	; 0x66e <main+0x50e>
            case PACKET_GPSFRAME:
                memset(&msg, 0, sizeof(message_t)-sizeof(msg.crc));
                msg.type = GPS;
                cli();
                for (i = 2; i<PACKET_SIZE-GPS_MSGSIZE; i += GPS_MSGSIZE) {
                    memcpy(gpsmsg, new_packet+i, GPS_MSGSIZE);
 672:	80 91 1e 02 	lds	r24, 0x021E
 676:	90 91 1f 02 	lds	r25, 0x021F
 67a:	9c 01       	movw	r18, r24
 67c:	d9 01       	movw	r26, r18
 67e:	e2 ec       	ldi	r30, 0xC2	; 194
 680:	f1 e0       	ldi	r31, 0x01	; 1
 682:	88 e0       	ldi	r24, 0x08	; 8
 684:	01 90       	ld	r0, Z+
 686:	0d 92       	st	X+, r0
 688:	81 50       	subi	r24, 0x01	; 1
 68a:	e1 f7       	brne	.-8      	; 0x684 <main+0x524>
                    if (gpsmsg->id == 0 && gpsmsg->x == 0 && gpsmsg->y == 0 && gpsmsg->theta == 0 && gpsmsg->unused == 0)
 68c:	e0 91 1e 02 	lds	r30, 0x021E
 690:	f0 91 1f 02 	lds	r31, 0x021F
 694:	80 81       	ld	r24, Z
 696:	91 81       	ldd	r25, Z+1	; 0x01
 698:	89 2b       	or	r24, r25
 69a:	81 f4       	brne	.+32     	; 0x6bc <main+0x55c>
 69c:	82 81       	ldd	r24, Z+2	; 0x02
 69e:	93 81       	ldd	r25, Z+3	; 0x03
 6a0:	89 2b       	or	r24, r25
 6a2:	61 f4       	brne	.+24     	; 0x6bc <main+0x55c>
 6a4:	84 81       	ldd	r24, Z+4	; 0x04
 6a6:	95 81       	ldd	r25, Z+5	; 0x05
 6a8:	89 2b       	or	r24, r25
 6aa:	41 f4       	brne	.+16     	; 0x6bc <main+0x55c>
 6ac:	86 81       	ldd	r24, Z+6	; 0x06
 6ae:	88 23       	and	r24, r24
 6b0:	29 f4       	brne	.+10     	; 0x6bc <main+0x55c>
 6b2:	87 81       	ldd	r24, Z+7	; 0x07
 6b4:	90 85       	ldd	r25, Z+8	; 0x08
 6b6:	89 2b       	or	r24, r25
 6b8:	09 f4       	brne	.+2      	; 0x6bc <main+0x55c>
 6ba:	16 c2       	rjmp	.+1068   	; 0xae8 <__stack+0x1e9>
                        break;
                    msg.crc = message_crc(&msg);
 6bc:	8b e8       	ldi	r24, 0x8B	; 139
 6be:	91 e0       	ldi	r25, 0x01	; 1
 6c0:	0e 94 00 06 	call	0xc00	; 0xc00 <message_crc>
 6c4:	90 93 96 01 	sts	0x0196, r25
 6c8:	80 93 95 01 	sts	0x0195, r24
                    message_send(&msg);
 6cc:	8b e8       	ldi	r24, 0x8B	; 139
 6ce:	91 e0       	ldi	r25, 0x01	; 1
 6d0:	0e 94 b9 06 	call	0xd72	; 0xd72 <message_send>
 6d4:	85 e8       	ldi	r24, 0x85	; 133
 6d6:	8a 95       	dec	r24
 6d8:	f1 f7       	brne	.-4      	; 0x6d6 <main+0x576>
            case PACKET_GPSFRAME:
                memset(&msg, 0, sizeof(message_t)-sizeof(msg.crc));
                msg.type = GPS;
                cli();
                for (i = 2; i<PACKET_SIZE-GPS_MSGSIZE; i += GPS_MSGSIZE) {
                    memcpy(gpsmsg, new_packet+i, GPS_MSGSIZE);
 6da:	80 91 1e 02 	lds	r24, 0x021E
 6de:	90 91 1f 02 	lds	r25, 0x021F
 6e2:	9c 01       	movw	r18, r24
 6e4:	d9 01       	movw	r26, r18
 6e6:	ea ec       	ldi	r30, 0xCA	; 202
 6e8:	f1 e0       	ldi	r31, 0x01	; 1
 6ea:	88 e0       	ldi	r24, 0x08	; 8
 6ec:	01 90       	ld	r0, Z+
 6ee:	0d 92       	st	X+, r0
 6f0:	81 50       	subi	r24, 0x01	; 1
 6f2:	e1 f7       	brne	.-8      	; 0x6ec <main+0x58c>
                    if (gpsmsg->id == 0 && gpsmsg->x == 0 && gpsmsg->y == 0 && gpsmsg->theta == 0 && gpsmsg->unused == 0)
 6f4:	e0 91 1e 02 	lds	r30, 0x021E
 6f8:	f0 91 1f 02 	lds	r31, 0x021F
 6fc:	80 81       	ld	r24, Z
 6fe:	91 81       	ldd	r25, Z+1	; 0x01
 700:	89 2b       	or	r24, r25
 702:	81 f4       	brne	.+32     	; 0x724 <main+0x5c4>
 704:	82 81       	ldd	r24, Z+2	; 0x02
 706:	93 81       	ldd	r25, Z+3	; 0x03
 708:	89 2b       	or	r24, r25
 70a:	61 f4       	brne	.+24     	; 0x724 <main+0x5c4>
 70c:	84 81       	ldd	r24, Z+4	; 0x04
 70e:	95 81       	ldd	r25, Z+5	; 0x05
 710:	89 2b       	or	r24, r25
 712:	41 f4       	brne	.+16     	; 0x724 <main+0x5c4>
 714:	86 81       	ldd	r24, Z+6	; 0x06
 716:	88 23       	and	r24, r24
 718:	29 f4       	brne	.+10     	; 0x724 <main+0x5c4>
 71a:	87 81       	ldd	r24, Z+7	; 0x07
 71c:	90 85       	ldd	r25, Z+8	; 0x08
 71e:	89 2b       	or	r24, r25
 720:	09 f4       	brne	.+2      	; 0x724 <main+0x5c4>
 722:	e2 c1       	rjmp	.+964    	; 0xae8 <__stack+0x1e9>
                        break;
                    msg.crc = message_crc(&msg);
 724:	8b e8       	ldi	r24, 0x8B	; 139
 726:	91 e0       	ldi	r25, 0x01	; 1
 728:	0e 94 00 06 	call	0xc00	; 0xc00 <message_crc>
 72c:	90 93 96 01 	sts	0x0196, r25
 730:	80 93 95 01 	sts	0x0195, r24
                    message_send(&msg);
 734:	8b e8       	ldi	r24, 0x8B	; 139
 736:	91 e0       	ldi	r25, 0x01	; 1
 738:	0e 94 b9 06 	call	0xd72	; 0xd72 <message_send>
 73c:	85 e8       	ldi	r24, 0x85	; 133
 73e:	8a 95       	dec	r24
 740:	f1 f7       	brne	.-4      	; 0x73e <main+0x5de>
            case PACKET_GPSFRAME:
                memset(&msg, 0, sizeof(message_t)-sizeof(msg.crc));
                msg.type = GPS;
                cli();
                for (i = 2; i<PACKET_SIZE-GPS_MSGSIZE; i += GPS_MSGSIZE) {
                    memcpy(gpsmsg, new_packet+i, GPS_MSGSIZE);
 742:	80 91 1e 02 	lds	r24, 0x021E
 746:	90 91 1f 02 	lds	r25, 0x021F
 74a:	9c 01       	movw	r18, r24
 74c:	d9 01       	movw	r26, r18
 74e:	e2 ed       	ldi	r30, 0xD2	; 210
 750:	f1 e0       	ldi	r31, 0x01	; 1
 752:	88 e0       	ldi	r24, 0x08	; 8
 754:	01 90       	ld	r0, Z+
 756:	0d 92       	st	X+, r0
 758:	81 50       	subi	r24, 0x01	; 1
 75a:	e1 f7       	brne	.-8      	; 0x754 <main+0x5f4>
                    if (gpsmsg->id == 0 && gpsmsg->x == 0 && gpsmsg->y == 0 && gpsmsg->theta == 0 && gpsmsg->unused == 0)
 75c:	e0 91 1e 02 	lds	r30, 0x021E
 760:	f0 91 1f 02 	lds	r31, 0x021F
 764:	80 81       	ld	r24, Z
 766:	91 81       	ldd	r25, Z+1	; 0x01
 768:	89 2b       	or	r24, r25
 76a:	81 f4       	brne	.+32     	; 0x78c <main+0x62c>
 76c:	82 81       	ldd	r24, Z+2	; 0x02
 76e:	93 81       	ldd	r25, Z+3	; 0x03
 770:	89 2b       	or	r24, r25
 772:	61 f4       	brne	.+24     	; 0x78c <main+0x62c>
 774:	84 81       	ldd	r24, Z+4	; 0x04
 776:	95 81       	ldd	r25, Z+5	; 0x05
 778:	89 2b       	or	r24, r25
 77a:	41 f4       	brne	.+16     	; 0x78c <main+0x62c>
 77c:	86 81       	ldd	r24, Z+6	; 0x06
 77e:	88 23       	and	r24, r24
 780:	29 f4       	brne	.+10     	; 0x78c <main+0x62c>
 782:	87 81       	ldd	r24, Z+7	; 0x07
 784:	90 85       	ldd	r25, Z+8	; 0x08
 786:	89 2b       	or	r24, r25
 788:	09 f4       	brne	.+2      	; 0x78c <main+0x62c>
 78a:	ae c1       	rjmp	.+860    	; 0xae8 <__stack+0x1e9>
                        break;
                    msg.crc = message_crc(&msg);
 78c:	8b e8       	ldi	r24, 0x8B	; 139
 78e:	91 e0       	ldi	r25, 0x01	; 1
 790:	0e 94 00 06 	call	0xc00	; 0xc00 <message_crc>
 794:	90 93 96 01 	sts	0x0196, r25
 798:	80 93 95 01 	sts	0x0195, r24
                    message_send(&msg);
 79c:	8b e8       	ldi	r24, 0x8B	; 139
 79e:	91 e0       	ldi	r25, 0x01	; 1
 7a0:	0e 94 b9 06 	call	0xd72	; 0xd72 <message_send>
 7a4:	85 e8       	ldi	r24, 0x85	; 133
 7a6:	8a 95       	dec	r24
 7a8:	f1 f7       	brne	.-4      	; 0x7a6 <main+0x646>
            case PACKET_GPSFRAME:
                memset(&msg, 0, sizeof(message_t)-sizeof(msg.crc));
                msg.type = GPS;
                cli();
                for (i = 2; i<PACKET_SIZE-GPS_MSGSIZE; i += GPS_MSGSIZE) {
                    memcpy(gpsmsg, new_packet+i, GPS_MSGSIZE);
 7aa:	80 91 1e 02 	lds	r24, 0x021E
 7ae:	90 91 1f 02 	lds	r25, 0x021F
 7b2:	9c 01       	movw	r18, r24
 7b4:	d9 01       	movw	r26, r18
 7b6:	ea ed       	ldi	r30, 0xDA	; 218
 7b8:	f1 e0       	ldi	r31, 0x01	; 1
 7ba:	88 e0       	ldi	r24, 0x08	; 8
 7bc:	01 90       	ld	r0, Z+
 7be:	0d 92       	st	X+, r0
 7c0:	81 50       	subi	r24, 0x01	; 1
 7c2:	e1 f7       	brne	.-8      	; 0x7bc <main+0x65c>
                    if (gpsmsg->id == 0 && gpsmsg->x == 0 && gpsmsg->y == 0 && gpsmsg->theta == 0 && gpsmsg->unused == 0)
 7c4:	e0 91 1e 02 	lds	r30, 0x021E
 7c8:	f0 91 1f 02 	lds	r31, 0x021F
 7cc:	80 81       	ld	r24, Z
 7ce:	91 81       	ldd	r25, Z+1	; 0x01
 7d0:	89 2b       	or	r24, r25
 7d2:	81 f4       	brne	.+32     	; 0x7f4 <main+0x694>
 7d4:	82 81       	ldd	r24, Z+2	; 0x02
 7d6:	93 81       	ldd	r25, Z+3	; 0x03
 7d8:	89 2b       	or	r24, r25
 7da:	61 f4       	brne	.+24     	; 0x7f4 <main+0x694>
 7dc:	84 81       	ldd	r24, Z+4	; 0x04
 7de:	95 81       	ldd	r25, Z+5	; 0x05
 7e0:	89 2b       	or	r24, r25
 7e2:	41 f4       	brne	.+16     	; 0x7f4 <main+0x694>
 7e4:	86 81       	ldd	r24, Z+6	; 0x06
 7e6:	88 23       	and	r24, r24
 7e8:	29 f4       	brne	.+10     	; 0x7f4 <main+0x694>
 7ea:	87 81       	ldd	r24, Z+7	; 0x07
 7ec:	90 85       	ldd	r25, Z+8	; 0x08
 7ee:	89 2b       	or	r24, r25
 7f0:	09 f4       	brne	.+2      	; 0x7f4 <main+0x694>
 7f2:	7a c1       	rjmp	.+756    	; 0xae8 <__stack+0x1e9>
                        break;
                    msg.crc = message_crc(&msg);
 7f4:	8b e8       	ldi	r24, 0x8B	; 139
 7f6:	91 e0       	ldi	r25, 0x01	; 1
 7f8:	0e 94 00 06 	call	0xc00	; 0xc00 <message_crc>
 7fc:	90 93 96 01 	sts	0x0196, r25
 800:	80 93 95 01 	sts	0x0195, r24
                    message_send(&msg);
 804:	8b e8       	ldi	r24, 0x8B	; 139
 806:	91 e0       	ldi	r25, 0x01	; 1
 808:	0e 94 b9 06 	call	0xd72	; 0xd72 <message_send>
 80c:	85 e8       	ldi	r24, 0x85	; 133
 80e:	8a 95       	dec	r24
 810:	f1 f7       	brne	.-4      	; 0x80e <main+0x6ae>
            case PACKET_GPSFRAME:
                memset(&msg, 0, sizeof(message_t)-sizeof(msg.crc));
                msg.type = GPS;
                cli();
                for (i = 2; i<PACKET_SIZE-GPS_MSGSIZE; i += GPS_MSGSIZE) {
                    memcpy(gpsmsg, new_packet+i, GPS_MSGSIZE);
 812:	80 91 1e 02 	lds	r24, 0x021E
 816:	90 91 1f 02 	lds	r25, 0x021F
 81a:	9c 01       	movw	r18, r24
 81c:	d9 01       	movw	r26, r18
 81e:	e2 ee       	ldi	r30, 0xE2	; 226
 820:	f1 e0       	ldi	r31, 0x01	; 1
 822:	88 e0       	ldi	r24, 0x08	; 8
 824:	01 90       	ld	r0, Z+
 826:	0d 92       	st	X+, r0
 828:	81 50       	subi	r24, 0x01	; 1
 82a:	e1 f7       	brne	.-8      	; 0x824 <main+0x6c4>
                    if (gpsmsg->id == 0 && gpsmsg->x == 0 && gpsmsg->y == 0 && gpsmsg->theta == 0 && gpsmsg->unused == 0)
 82c:	e0 91 1e 02 	lds	r30, 0x021E
 830:	f0 91 1f 02 	lds	r31, 0x021F
 834:	80 81       	ld	r24, Z
 836:	91 81       	ldd	r25, Z+1	; 0x01
 838:	89 2b       	or	r24, r25
 83a:	81 f4       	brne	.+32     	; 0x85c <main+0x6fc>
 83c:	82 81       	ldd	r24, Z+2	; 0x02
 83e:	93 81       	ldd	r25, Z+3	; 0x03
 840:	89 2b       	or	r24, r25
 842:	61 f4       	brne	.+24     	; 0x85c <main+0x6fc>
 844:	84 81       	ldd	r24, Z+4	; 0x04
 846:	95 81       	ldd	r25, Z+5	; 0x05
 848:	89 2b       	or	r24, r25
 84a:	41 f4       	brne	.+16     	; 0x85c <main+0x6fc>
 84c:	86 81       	ldd	r24, Z+6	; 0x06
 84e:	88 23       	and	r24, r24
 850:	29 f4       	brne	.+10     	; 0x85c <main+0x6fc>
 852:	87 81       	ldd	r24, Z+7	; 0x07
 854:	90 85       	ldd	r25, Z+8	; 0x08
 856:	89 2b       	or	r24, r25
 858:	09 f4       	brne	.+2      	; 0x85c <main+0x6fc>
 85a:	46 c1       	rjmp	.+652    	; 0xae8 <__stack+0x1e9>
                        break;
                    msg.crc = message_crc(&msg);
 85c:	8b e8       	ldi	r24, 0x8B	; 139
 85e:	91 e0       	ldi	r25, 0x01	; 1
 860:	0e 94 00 06 	call	0xc00	; 0xc00 <message_crc>
 864:	90 93 96 01 	sts	0x0196, r25
 868:	80 93 95 01 	sts	0x0195, r24
                    message_send(&msg);
 86c:	8b e8       	ldi	r24, 0x8B	; 139
 86e:	91 e0       	ldi	r25, 0x01	; 1
 870:	0e 94 b9 06 	call	0xd72	; 0xd72 <message_send>
 874:	85 e8       	ldi	r24, 0x85	; 133
 876:	8a 95       	dec	r24
 878:	f1 f7       	brne	.-4      	; 0x876 <main+0x716>
            case PACKET_GPSFRAME:
                memset(&msg, 0, sizeof(message_t)-sizeof(msg.crc));
                msg.type = GPS;
                cli();
                for (i = 2; i<PACKET_SIZE-GPS_MSGSIZE; i += GPS_MSGSIZE) {
                    memcpy(gpsmsg, new_packet+i, GPS_MSGSIZE);
 87a:	80 91 1e 02 	lds	r24, 0x021E
 87e:	90 91 1f 02 	lds	r25, 0x021F
 882:	9c 01       	movw	r18, r24
 884:	d9 01       	movw	r26, r18
 886:	ea ee       	ldi	r30, 0xEA	; 234
 888:	f1 e0       	ldi	r31, 0x01	; 1
 88a:	88 e0       	ldi	r24, 0x08	; 8
 88c:	01 90       	ld	r0, Z+
 88e:	0d 92       	st	X+, r0
 890:	81 50       	subi	r24, 0x01	; 1
 892:	e1 f7       	brne	.-8      	; 0x88c <main+0x72c>
                    if (gpsmsg->id == 0 && gpsmsg->x == 0 && gpsmsg->y == 0 && gpsmsg->theta == 0 && gpsmsg->unused == 0)
 894:	e0 91 1e 02 	lds	r30, 0x021E
 898:	f0 91 1f 02 	lds	r31, 0x021F
 89c:	80 81       	ld	r24, Z
 89e:	91 81       	ldd	r25, Z+1	; 0x01
 8a0:	89 2b       	or	r24, r25
 8a2:	81 f4       	brne	.+32     	; 0x8c4 <main+0x764>
 8a4:	82 81       	ldd	r24, Z+2	; 0x02
 8a6:	93 81       	ldd	r25, Z+3	; 0x03
 8a8:	89 2b       	or	r24, r25
 8aa:	61 f4       	brne	.+24     	; 0x8c4 <main+0x764>
 8ac:	84 81       	ldd	r24, Z+4	; 0x04
 8ae:	95 81       	ldd	r25, Z+5	; 0x05
 8b0:	89 2b       	or	r24, r25
 8b2:	41 f4       	brne	.+16     	; 0x8c4 <main+0x764>
 8b4:	86 81       	ldd	r24, Z+6	; 0x06
 8b6:	88 23       	and	r24, r24
 8b8:	29 f4       	brne	.+10     	; 0x8c4 <main+0x764>
 8ba:	87 81       	ldd	r24, Z+7	; 0x07
 8bc:	90 85       	ldd	r25, Z+8	; 0x08
 8be:	89 2b       	or	r24, r25
 8c0:	09 f4       	brne	.+2      	; 0x8c4 <main+0x764>
 8c2:	12 c1       	rjmp	.+548    	; 0xae8 <__stack+0x1e9>
                        break;
                    msg.crc = message_crc(&msg);
 8c4:	8b e8       	ldi	r24, 0x8B	; 139
 8c6:	91 e0       	ldi	r25, 0x01	; 1
 8c8:	0e 94 00 06 	call	0xc00	; 0xc00 <message_crc>
 8cc:	90 93 96 01 	sts	0x0196, r25
 8d0:	80 93 95 01 	sts	0x0195, r24
                    message_send(&msg);
 8d4:	8b e8       	ldi	r24, 0x8B	; 139
 8d6:	91 e0       	ldi	r25, 0x01	; 1
 8d8:	0e 94 b9 06 	call	0xd72	; 0xd72 <message_send>
 8dc:	85 e8       	ldi	r24, 0x85	; 133
 8de:	8a 95       	dec	r24
 8e0:	f1 f7       	brne	.-4      	; 0x8de <main+0x77e>
            case PACKET_GPSFRAME:
                memset(&msg, 0, sizeof(message_t)-sizeof(msg.crc));
                msg.type = GPS;
                cli();
                for (i = 2; i<PACKET_SIZE-GPS_MSGSIZE; i += GPS_MSGSIZE) {
                    memcpy(gpsmsg, new_packet+i, GPS_MSGSIZE);
 8e2:	80 91 1e 02 	lds	r24, 0x021E
 8e6:	90 91 1f 02 	lds	r25, 0x021F
 8ea:	9c 01       	movw	r18, r24
 8ec:	d9 01       	movw	r26, r18
 8ee:	e2 ef       	ldi	r30, 0xF2	; 242
 8f0:	f1 e0       	ldi	r31, 0x01	; 1
 8f2:	88 e0       	ldi	r24, 0x08	; 8
 8f4:	01 90       	ld	r0, Z+
 8f6:	0d 92       	st	X+, r0
 8f8:	81 50       	subi	r24, 0x01	; 1
 8fa:	e1 f7       	brne	.-8      	; 0x8f4 <main+0x794>
                    if (gpsmsg->id == 0 && gpsmsg->x == 0 && gpsmsg->y == 0 && gpsmsg->theta == 0 && gpsmsg->unused == 0)
 8fc:	e0 91 1e 02 	lds	r30, 0x021E
 900:	f0 91 1f 02 	lds	r31, 0x021F
 904:	80 81       	ld	r24, Z
 906:	91 81       	ldd	r25, Z+1	; 0x01
 908:	89 2b       	or	r24, r25
 90a:	81 f4       	brne	.+32     	; 0x92c <__stack+0x2d>
 90c:	82 81       	ldd	r24, Z+2	; 0x02
 90e:	93 81       	ldd	r25, Z+3	; 0x03
 910:	89 2b       	or	r24, r25
 912:	61 f4       	brne	.+24     	; 0x92c <__stack+0x2d>
 914:	84 81       	ldd	r24, Z+4	; 0x04
 916:	95 81       	ldd	r25, Z+5	; 0x05
 918:	89 2b       	or	r24, r25
 91a:	41 f4       	brne	.+16     	; 0x92c <__stack+0x2d>
 91c:	86 81       	ldd	r24, Z+6	; 0x06
 91e:	88 23       	and	r24, r24
 920:	29 f4       	brne	.+10     	; 0x92c <__stack+0x2d>
 922:	87 81       	ldd	r24, Z+7	; 0x07
 924:	90 85       	ldd	r25, Z+8	; 0x08
 926:	89 2b       	or	r24, r25
 928:	09 f4       	brne	.+2      	; 0x92c <__stack+0x2d>
 92a:	de c0       	rjmp	.+444    	; 0xae8 <__stack+0x1e9>
                        break;
                    msg.crc = message_crc(&msg);
 92c:	8b e8       	ldi	r24, 0x8B	; 139
 92e:	91 e0       	ldi	r25, 0x01	; 1
 930:	0e 94 00 06 	call	0xc00	; 0xc00 <message_crc>
 934:	90 93 96 01 	sts	0x0196, r25
 938:	80 93 95 01 	sts	0x0195, r24
                    message_send(&msg);
 93c:	8b e8       	ldi	r24, 0x8B	; 139
 93e:	91 e0       	ldi	r25, 0x01	; 1
 940:	0e 94 b9 06 	call	0xd72	; 0xd72 <message_send>
 944:	85 e8       	ldi	r24, 0x85	; 133
 946:	8a 95       	dec	r24
 948:	f1 f7       	brne	.-4      	; 0x946 <__stack+0x47>
            case PACKET_GPSFRAME:
                memset(&msg, 0, sizeof(message_t)-sizeof(msg.crc));
                msg.type = GPS;
                cli();
                for (i = 2; i<PACKET_SIZE-GPS_MSGSIZE; i += GPS_MSGSIZE) {
                    memcpy(gpsmsg, new_packet+i, GPS_MSGSIZE);
 94a:	80 91 1e 02 	lds	r24, 0x021E
 94e:	90 91 1f 02 	lds	r25, 0x021F
 952:	9c 01       	movw	r18, r24
 954:	d9 01       	movw	r26, r18
 956:	ea ef       	ldi	r30, 0xFA	; 250
 958:	f1 e0       	ldi	r31, 0x01	; 1
 95a:	88 e0       	ldi	r24, 0x08	; 8
 95c:	01 90       	ld	r0, Z+
 95e:	0d 92       	st	X+, r0
 960:	81 50       	subi	r24, 0x01	; 1
 962:	e1 f7       	brne	.-8      	; 0x95c <__stack+0x5d>
                    if (gpsmsg->id == 0 && gpsmsg->x == 0 && gpsmsg->y == 0 && gpsmsg->theta == 0 && gpsmsg->unused == 0)
 964:	e0 91 1e 02 	lds	r30, 0x021E
 968:	f0 91 1f 02 	lds	r31, 0x021F
 96c:	80 81       	ld	r24, Z
 96e:	91 81       	ldd	r25, Z+1	; 0x01
 970:	89 2b       	or	r24, r25
 972:	81 f4       	brne	.+32     	; 0x994 <__stack+0x95>
 974:	82 81       	ldd	r24, Z+2	; 0x02
 976:	93 81       	ldd	r25, Z+3	; 0x03
 978:	89 2b       	or	r24, r25
 97a:	61 f4       	brne	.+24     	; 0x994 <__stack+0x95>
 97c:	84 81       	ldd	r24, Z+4	; 0x04
 97e:	95 81       	ldd	r25, Z+5	; 0x05
 980:	89 2b       	or	r24, r25
 982:	41 f4       	brne	.+16     	; 0x994 <__stack+0x95>
 984:	86 81       	ldd	r24, Z+6	; 0x06
 986:	88 23       	and	r24, r24
 988:	29 f4       	brne	.+10     	; 0x994 <__stack+0x95>
 98a:	87 81       	ldd	r24, Z+7	; 0x07
 98c:	90 85       	ldd	r25, Z+8	; 0x08
 98e:	89 2b       	or	r24, r25
 990:	09 f4       	brne	.+2      	; 0x994 <__stack+0x95>
 992:	aa c0       	rjmp	.+340    	; 0xae8 <__stack+0x1e9>
                        break;
                    msg.crc = message_crc(&msg);
 994:	8b e8       	ldi	r24, 0x8B	; 139
 996:	91 e0       	ldi	r25, 0x01	; 1
 998:	0e 94 00 06 	call	0xc00	; 0xc00 <message_crc>
 99c:	90 93 96 01 	sts	0x0196, r25
 9a0:	80 93 95 01 	sts	0x0195, r24
                    message_send(&msg);
 9a4:	8b e8       	ldi	r24, 0x8B	; 139
 9a6:	91 e0       	ldi	r25, 0x01	; 1
 9a8:	0e 94 b9 06 	call	0xd72	; 0xd72 <message_send>
 9ac:	85 e8       	ldi	r24, 0x85	; 133
 9ae:	8a 95       	dec	r24
 9b0:	f1 f7       	brne	.-4      	; 0x9ae <__stack+0xaf>
            case PACKET_GPSFRAME:
                memset(&msg, 0, sizeof(message_t)-sizeof(msg.crc));
                msg.type = GPS;
                cli();
                for (i = 2; i<PACKET_SIZE-GPS_MSGSIZE; i += GPS_MSGSIZE) {
                    memcpy(gpsmsg, new_packet+i, GPS_MSGSIZE);
 9b2:	80 91 1e 02 	lds	r24, 0x021E
 9b6:	90 91 1f 02 	lds	r25, 0x021F
 9ba:	9c 01       	movw	r18, r24
 9bc:	d9 01       	movw	r26, r18
 9be:	e2 e0       	ldi	r30, 0x02	; 2
 9c0:	f2 e0       	ldi	r31, 0x02	; 2
 9c2:	88 e0       	ldi	r24, 0x08	; 8
 9c4:	01 90       	ld	r0, Z+
 9c6:	0d 92       	st	X+, r0
 9c8:	81 50       	subi	r24, 0x01	; 1
 9ca:	e1 f7       	brne	.-8      	; 0x9c4 <__stack+0xc5>
                    if (gpsmsg->id == 0 && gpsmsg->x == 0 && gpsmsg->y == 0 && gpsmsg->theta == 0 && gpsmsg->unused == 0)
 9cc:	e0 91 1e 02 	lds	r30, 0x021E
 9d0:	f0 91 1f 02 	lds	r31, 0x021F
 9d4:	80 81       	ld	r24, Z
 9d6:	91 81       	ldd	r25, Z+1	; 0x01
 9d8:	89 2b       	or	r24, r25
 9da:	81 f4       	brne	.+32     	; 0x9fc <__stack+0xfd>
 9dc:	82 81       	ldd	r24, Z+2	; 0x02
 9de:	93 81       	ldd	r25, Z+3	; 0x03
 9e0:	89 2b       	or	r24, r25
 9e2:	61 f4       	brne	.+24     	; 0x9fc <__stack+0xfd>
 9e4:	84 81       	ldd	r24, Z+4	; 0x04
 9e6:	95 81       	ldd	r25, Z+5	; 0x05
 9e8:	89 2b       	or	r24, r25
 9ea:	41 f4       	brne	.+16     	; 0x9fc <__stack+0xfd>
 9ec:	86 81       	ldd	r24, Z+6	; 0x06
 9ee:	88 23       	and	r24, r24
 9f0:	29 f4       	brne	.+10     	; 0x9fc <__stack+0xfd>
 9f2:	87 81       	ldd	r24, Z+7	; 0x07
 9f4:	90 85       	ldd	r25, Z+8	; 0x08
 9f6:	89 2b       	or	r24, r25
 9f8:	09 f4       	brne	.+2      	; 0x9fc <__stack+0xfd>
 9fa:	76 c0       	rjmp	.+236    	; 0xae8 <__stack+0x1e9>
                        break;
                    msg.crc = message_crc(&msg);
 9fc:	8b e8       	ldi	r24, 0x8B	; 139
 9fe:	91 e0       	ldi	r25, 0x01	; 1
 a00:	0e 94 00 06 	call	0xc00	; 0xc00 <message_crc>
 a04:	90 93 96 01 	sts	0x0196, r25
 a08:	80 93 95 01 	sts	0x0195, r24
                    message_send(&msg);
 a0c:	8b e8       	ldi	r24, 0x8B	; 139
 a0e:	91 e0       	ldi	r25, 0x01	; 1
 a10:	0e 94 b9 06 	call	0xd72	; 0xd72 <message_send>
 a14:	85 e8       	ldi	r24, 0x85	; 133
 a16:	8a 95       	dec	r24
 a18:	f1 f7       	brne	.-4      	; 0xa16 <__stack+0x117>
            case PACKET_GPSFRAME:
                memset(&msg, 0, sizeof(message_t)-sizeof(msg.crc));
                msg.type = GPS;
                cli();
                for (i = 2; i<PACKET_SIZE-GPS_MSGSIZE; i += GPS_MSGSIZE) {
                    memcpy(gpsmsg, new_packet+i, GPS_MSGSIZE);
 a1a:	80 91 1e 02 	lds	r24, 0x021E
 a1e:	90 91 1f 02 	lds	r25, 0x021F
 a22:	9c 01       	movw	r18, r24
 a24:	d9 01       	movw	r26, r18
 a26:	ea e0       	ldi	r30, 0x0A	; 10
 a28:	f2 e0       	ldi	r31, 0x02	; 2
 a2a:	88 e0       	ldi	r24, 0x08	; 8
 a2c:	01 90       	ld	r0, Z+
 a2e:	0d 92       	st	X+, r0
 a30:	81 50       	subi	r24, 0x01	; 1
 a32:	e1 f7       	brne	.-8      	; 0xa2c <__stack+0x12d>
                    if (gpsmsg->id == 0 && gpsmsg->x == 0 && gpsmsg->y == 0 && gpsmsg->theta == 0 && gpsmsg->unused == 0)
 a34:	e0 91 1e 02 	lds	r30, 0x021E
 a38:	f0 91 1f 02 	lds	r31, 0x021F
 a3c:	80 81       	ld	r24, Z
 a3e:	91 81       	ldd	r25, Z+1	; 0x01
 a40:	89 2b       	or	r24, r25
 a42:	81 f4       	brne	.+32     	; 0xa64 <__stack+0x165>
 a44:	82 81       	ldd	r24, Z+2	; 0x02
 a46:	93 81       	ldd	r25, Z+3	; 0x03
 a48:	89 2b       	or	r24, r25
 a4a:	61 f4       	brne	.+24     	; 0xa64 <__stack+0x165>
 a4c:	84 81       	ldd	r24, Z+4	; 0x04
 a4e:	95 81       	ldd	r25, Z+5	; 0x05
 a50:	89 2b       	or	r24, r25
 a52:	41 f4       	brne	.+16     	; 0xa64 <__stack+0x165>
 a54:	86 81       	ldd	r24, Z+6	; 0x06
 a56:	88 23       	and	r24, r24
 a58:	29 f4       	brne	.+10     	; 0xa64 <__stack+0x165>
 a5a:	87 81       	ldd	r24, Z+7	; 0x07
 a5c:	90 85       	ldd	r25, Z+8	; 0x08
 a5e:	89 2b       	or	r24, r25
 a60:	09 f4       	brne	.+2      	; 0xa64 <__stack+0x165>
 a62:	42 c0       	rjmp	.+132    	; 0xae8 <__stack+0x1e9>
                        break;
                    msg.crc = message_crc(&msg);
 a64:	8b e8       	ldi	r24, 0x8B	; 139
 a66:	91 e0       	ldi	r25, 0x01	; 1
 a68:	0e 94 00 06 	call	0xc00	; 0xc00 <message_crc>
 a6c:	90 93 96 01 	sts	0x0196, r25
 a70:	80 93 95 01 	sts	0x0195, r24
                    message_send(&msg);
 a74:	8b e8       	ldi	r24, 0x8B	; 139
 a76:	91 e0       	ldi	r25, 0x01	; 1
 a78:	0e 94 b9 06 	call	0xd72	; 0xd72 <message_send>
 a7c:	85 e8       	ldi	r24, 0x85	; 133
 a7e:	8a 95       	dec	r24
 a80:	f1 f7       	brne	.-4      	; 0xa7e <__stack+0x17f>
            case PACKET_GPSFRAME:
                memset(&msg, 0, sizeof(message_t)-sizeof(msg.crc));
                msg.type = GPS;
                cli();
                for (i = 2; i<PACKET_SIZE-GPS_MSGSIZE; i += GPS_MSGSIZE) {
                    memcpy(gpsmsg, new_packet+i, GPS_MSGSIZE);
 a82:	80 91 1e 02 	lds	r24, 0x021E
 a86:	90 91 1f 02 	lds	r25, 0x021F
 a8a:	9c 01       	movw	r18, r24
 a8c:	d9 01       	movw	r26, r18
 a8e:	e2 e1       	ldi	r30, 0x12	; 18
 a90:	f2 e0       	ldi	r31, 0x02	; 2
 a92:	88 e0       	ldi	r24, 0x08	; 8
 a94:	01 90       	ld	r0, Z+
 a96:	0d 92       	st	X+, r0
 a98:	81 50       	subi	r24, 0x01	; 1
 a9a:	e1 f7       	brne	.-8      	; 0xa94 <__stack+0x195>
                    if (gpsmsg->id == 0 && gpsmsg->x == 0 && gpsmsg->y == 0 && gpsmsg->theta == 0 && gpsmsg->unused == 0)
 a9c:	e0 91 1e 02 	lds	r30, 0x021E
 aa0:	f0 91 1f 02 	lds	r31, 0x021F
 aa4:	80 81       	ld	r24, Z
 aa6:	91 81       	ldd	r25, Z+1	; 0x01
 aa8:	89 2b       	or	r24, r25
 aaa:	79 f4       	brne	.+30     	; 0xaca <__stack+0x1cb>
 aac:	82 81       	ldd	r24, Z+2	; 0x02
 aae:	93 81       	ldd	r25, Z+3	; 0x03
 ab0:	89 2b       	or	r24, r25
 ab2:	59 f4       	brne	.+22     	; 0xaca <__stack+0x1cb>
 ab4:	84 81       	ldd	r24, Z+4	; 0x04
 ab6:	95 81       	ldd	r25, Z+5	; 0x05
 ab8:	89 2b       	or	r24, r25
 aba:	39 f4       	brne	.+14     	; 0xaca <__stack+0x1cb>
 abc:	86 81       	ldd	r24, Z+6	; 0x06
 abe:	88 23       	and	r24, r24
 ac0:	21 f4       	brne	.+8      	; 0xaca <__stack+0x1cb>
 ac2:	87 81       	ldd	r24, Z+7	; 0x07
 ac4:	90 85       	ldd	r25, Z+8	; 0x08
 ac6:	89 2b       	or	r24, r25
 ac8:	79 f0       	breq	.+30     	; 0xae8 <__stack+0x1e9>
                        break;
                    msg.crc = message_crc(&msg);
 aca:	8b e8       	ldi	r24, 0x8B	; 139
 acc:	91 e0       	ldi	r25, 0x01	; 1
 ace:	0e 94 00 06 	call	0xc00	; 0xc00 <message_crc>
 ad2:	90 93 96 01 	sts	0x0196, r25
 ad6:	80 93 95 01 	sts	0x0195, r24
                    message_send(&msg);
 ada:	8b e8       	ldi	r24, 0x8B	; 139
 adc:	91 e0       	ldi	r25, 0x01	; 1
 ade:	0e 94 b9 06 	call	0xd72	; 0xd72 <message_send>
 ae2:	85 e8       	ldi	r24, 0x85	; 133
 ae4:	8a 95       	dec	r24
 ae6:	f1 f7       	brne	.-4      	; 0xae4 <__stack+0x1e5>
                    _delay_us(50);
                }
                sei();
 ae8:	78 94       	sei
 aea:	a7 cc       	rjmp	.-1714   	; 0x43a <main+0x2da>
            has_new_packet = 0;
            switch(packet_type) {
            case PACKET_STOP:
                break;
            case PACKET_LEDTOGGLE:
                leds_toggle = !leds_toggle;
 aec:	90 e0       	ldi	r25, 0x00	; 0
 aee:	80 91 04 01 	lds	r24, 0x0104
 af2:	88 23       	and	r24, r24
 af4:	09 f4       	brne	.+2      	; 0xaf8 <__stack+0x1f9>
 af6:	91 e0       	ldi	r25, 0x01	; 1
 af8:	90 93 04 01 	sts	0x0104, r25
                if (leds_toggle) {
 afc:	99 23       	and	r25, r25
 afe:	09 f4       	brne	.+2      	; 0xb02 <__stack+0x203>
 b00:	78 c0       	rjmp	.+240    	; 0xbf2 <__stack+0x2f3>
                    led_port |= led_mask;
 b02:	2d 9a       	sbi	0x05, 5	; 5
        led_port &= ~led_mask;
        _delay_ms(200);
    }

    while(1) {
        if (has_new_packet) {
 b04:	80 91 02 01 	lds	r24, 0x0102
 b08:	88 23       	and	r24, r24
 b0a:	09 f4       	brne	.+2      	; 0xb0e <__stack+0x20f>
 b0c:	7c cb       	rjmp	.-2312   	; 0x206 <main+0xa6>
 b0e:	7f cb       	rjmp	.-2306   	; 0x20e <main+0xae>
                led_port &= ~led_mask;
                _delay_ms(3);
                break;
            case PACKET_FORWARDRAWMSG:
                for (i = 0; i<sizeof(message_t); i++)
                    rawmsg[i] = new_packet[i+2];
 b10:	e0 91 1c 02 	lds	r30, 0x021C
 b14:	f0 91 1d 02 	lds	r31, 0x021D
 b18:	80 91 9a 01 	lds	r24, 0x019A
 b1c:	80 83       	st	Z, r24
 b1e:	e0 91 1c 02 	lds	r30, 0x021C
 b22:	f0 91 1d 02 	lds	r31, 0x021D
 b26:	80 91 9b 01 	lds	r24, 0x019B
 b2a:	81 83       	std	Z+1, r24	; 0x01
 b2c:	e0 91 1c 02 	lds	r30, 0x021C
 b30:	f0 91 1d 02 	lds	r31, 0x021D
 b34:	80 91 9c 01 	lds	r24, 0x019C
 b38:	82 83       	std	Z+2, r24	; 0x02
 b3a:	e0 91 1c 02 	lds	r30, 0x021C
 b3e:	f0 91 1d 02 	lds	r31, 0x021D
 b42:	80 91 9d 01 	lds	r24, 0x019D
 b46:	83 83       	std	Z+3, r24	; 0x03
 b48:	e0 91 1c 02 	lds	r30, 0x021C
 b4c:	f0 91 1d 02 	lds	r31, 0x021D
 b50:	80 91 9e 01 	lds	r24, 0x019E
 b54:	84 83       	std	Z+4, r24	; 0x04
 b56:	e0 91 1c 02 	lds	r30, 0x021C
 b5a:	f0 91 1d 02 	lds	r31, 0x021D
 b5e:	80 91 9f 01 	lds	r24, 0x019F
 b62:	85 83       	std	Z+5, r24	; 0x05
 b64:	e0 91 1c 02 	lds	r30, 0x021C
 b68:	f0 91 1d 02 	lds	r31, 0x021D
 b6c:	80 91 a0 01 	lds	r24, 0x01A0
 b70:	86 83       	std	Z+6, r24	; 0x06
 b72:	e0 91 1c 02 	lds	r30, 0x021C
 b76:	f0 91 1d 02 	lds	r31, 0x021D
 b7a:	80 91 a1 01 	lds	r24, 0x01A1
 b7e:	87 83       	std	Z+7, r24	; 0x07
 b80:	e0 91 1c 02 	lds	r30, 0x021C
 b84:	f0 91 1d 02 	lds	r31, 0x021D
 b88:	80 91 a2 01 	lds	r24, 0x01A2
 b8c:	80 87       	std	Z+8, r24	; 0x08
 b8e:	e0 91 1c 02 	lds	r30, 0x021C
 b92:	f0 91 1d 02 	lds	r31, 0x021D
 b96:	80 91 a3 01 	lds	r24, 0x01A3
 b9a:	81 87       	std	Z+9, r24	; 0x09
 b9c:	e0 91 1c 02 	lds	r30, 0x021C
 ba0:	f0 91 1d 02 	lds	r31, 0x021D
 ba4:	80 91 a4 01 	lds	r24, 0x01A4
 ba8:	82 87       	std	Z+10, r24	; 0x0a
 baa:	e0 91 1c 02 	lds	r30, 0x021C
 bae:	f0 91 1d 02 	lds	r31, 0x021D
 bb2:	80 91 a5 01 	lds	r24, 0x01A5
 bb6:	83 87       	std	Z+11, r24	; 0x0b
                while(!has_new_packet) {
 bb8:	80 91 02 01 	lds	r24, 0x0102
 bbc:	88 23       	and	r24, r24
 bbe:	09 f0       	breq	.+2      	; 0xbc2 <__stack+0x2c3>
 bc0:	22 cb       	rjmp	.-2492   	; 0x206 <main+0xa6>
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
 bc2:	c0 e7       	ldi	r28, 0x70	; 112
 bc4:	d7 e1       	ldi	r29, 0x17	; 23
                    message_send(&msg);
 bc6:	8b e8       	ldi	r24, 0x8B	; 139
 bc8:	91 e0       	ldi	r25, 0x01	; 1
 bca:	0e 94 b9 06 	call	0xd72	; 0xd72 <message_send>
                    led_port |= led_mask;
 bce:	2d 9a       	sbi	0x05, 5	; 5
 bd0:	ce 01       	movw	r24, r28
 bd2:	01 97       	sbiw	r24, 0x01	; 1
 bd4:	f1 f7       	brne	.-4      	; 0xbd2 <__stack+0x2d3>
                    _delay_ms(3);
                    led_port &= ~led_mask;
 bd6:	2d 98       	cbi	0x05, 5	; 5
 bd8:	ce 01       	movw	r24, r28
 bda:	01 97       	sbiw	r24, 0x01	; 1
 bdc:	f1 f7       	brne	.-4      	; 0xbda <__stack+0x2db>
                _delay_ms(3);
                break;
            case PACKET_FORWARDRAWMSG:
                for (i = 0; i<sizeof(message_t); i++)
                    rawmsg[i] = new_packet[i+2];
                while(!has_new_packet) {
 bde:	80 91 02 01 	lds	r24, 0x0102
 be2:	88 23       	and	r24, r24
 be4:	81 f3       	breq	.-32     	; 0xbc6 <__stack+0x2c7>
        led_port &= ~led_mask;
        _delay_ms(200);
    }

    while(1) {
        if (has_new_packet) {
 be6:	80 91 02 01 	lds	r24, 0x0102
 bea:	88 23       	and	r24, r24
 bec:	09 f4       	brne	.+2      	; 0xbf0 <__stack+0x2f1>
 bee:	0b cb       	rjmp	.-2538   	; 0x206 <main+0xa6>
 bf0:	0e cb       	rjmp	.-2532   	; 0x20e <main+0xae>
            case PACKET_LEDTOGGLE:
                leds_toggle = !leds_toggle;
                if (leds_toggle) {
                    led_port |= led_mask;
                } else {
                    led_port &= ~led_mask;
 bf2:	2d 98       	cbi	0x05, 5	; 5
        led_port &= ~led_mask;
        _delay_ms(200);
    }

    while(1) {
        if (has_new_packet) {
 bf4:	80 91 02 01 	lds	r24, 0x0102
 bf8:	88 23       	and	r24, r24
 bfa:	09 f4       	brne	.+2      	; 0xbfe <__stack+0x2ff>
 bfc:	04 cb       	rjmp	.-2552   	; 0x206 <main+0xa6>
 bfe:	07 cb       	rjmp	.-2546   	; 0x20e <main+0xae>

00000c00 <message_crc>:
#include "message.h"
#include <util/crc16.h>  // for optimized crc routines

uint16_t message_crc(const message_t *msg) {
 c00:	fc 01       	movw	r30, r24
static __inline__ uint16_t
_crc_ccitt_update (uint16_t __crc, uint8_t __data)
{
    uint16_t __ret;

    __asm__ __volatile__ (
 c02:	80 81       	ld	r24, Z
 c04:	2f ef       	ldi	r18, 0xFF	; 255
 c06:	3f ef       	ldi	r19, 0xFF	; 255
 c08:	28 27       	eor	r18, r24
 c0a:	02 2e       	mov	r0, r18
 c0c:	22 95       	swap	r18
 c0e:	20 7f       	andi	r18, 0xF0	; 240
 c10:	20 25       	eor	r18, r0
 c12:	03 2e       	mov	r0, r19
 c14:	32 2f       	mov	r19, r18
 c16:	22 95       	swap	r18
 c18:	2f 70       	andi	r18, 0x0F	; 15
 c1a:	02 26       	eor	r0, r18
 c1c:	26 95       	lsr	r18
 c1e:	32 27       	eor	r19, r18
 c20:	23 27       	eor	r18, r19
 c22:	22 0f       	add	r18, r18
 c24:	22 0f       	add	r18, r18
 c26:	22 0f       	add	r18, r18
 c28:	20 25       	eor	r18, r0
 c2a:	81 81       	ldd	r24, Z+1	; 0x01
 c2c:	28 27       	eor	r18, r24
 c2e:	02 2e       	mov	r0, r18
 c30:	22 95       	swap	r18
 c32:	20 7f       	andi	r18, 0xF0	; 240
 c34:	20 25       	eor	r18, r0
 c36:	03 2e       	mov	r0, r19
 c38:	32 2f       	mov	r19, r18
 c3a:	22 95       	swap	r18
 c3c:	2f 70       	andi	r18, 0x0F	; 15
 c3e:	02 26       	eor	r0, r18
 c40:	26 95       	lsr	r18
 c42:	32 27       	eor	r19, r18
 c44:	23 27       	eor	r18, r19
 c46:	22 0f       	add	r18, r18
 c48:	22 0f       	add	r18, r18
 c4a:	22 0f       	add	r18, r18
 c4c:	20 25       	eor	r18, r0
 c4e:	82 81       	ldd	r24, Z+2	; 0x02
 c50:	28 27       	eor	r18, r24
 c52:	02 2e       	mov	r0, r18
 c54:	22 95       	swap	r18
 c56:	20 7f       	andi	r18, 0xF0	; 240
 c58:	20 25       	eor	r18, r0
 c5a:	03 2e       	mov	r0, r19
 c5c:	32 2f       	mov	r19, r18
 c5e:	22 95       	swap	r18
 c60:	2f 70       	andi	r18, 0x0F	; 15
 c62:	02 26       	eor	r0, r18
 c64:	26 95       	lsr	r18
 c66:	32 27       	eor	r19, r18
 c68:	23 27       	eor	r18, r19
 c6a:	22 0f       	add	r18, r18
 c6c:	22 0f       	add	r18, r18
 c6e:	22 0f       	add	r18, r18
 c70:	20 25       	eor	r18, r0
 c72:	83 81       	ldd	r24, Z+3	; 0x03
 c74:	28 27       	eor	r18, r24
 c76:	02 2e       	mov	r0, r18
 c78:	22 95       	swap	r18
 c7a:	20 7f       	andi	r18, 0xF0	; 240
 c7c:	20 25       	eor	r18, r0
 c7e:	03 2e       	mov	r0, r19
 c80:	32 2f       	mov	r19, r18
 c82:	22 95       	swap	r18
 c84:	2f 70       	andi	r18, 0x0F	; 15
 c86:	02 26       	eor	r0, r18
 c88:	26 95       	lsr	r18
 c8a:	32 27       	eor	r19, r18
 c8c:	23 27       	eor	r18, r19
 c8e:	22 0f       	add	r18, r18
 c90:	22 0f       	add	r18, r18
 c92:	22 0f       	add	r18, r18
 c94:	20 25       	eor	r18, r0
 c96:	84 81       	ldd	r24, Z+4	; 0x04
 c98:	28 27       	eor	r18, r24
 c9a:	02 2e       	mov	r0, r18
 c9c:	22 95       	swap	r18
 c9e:	20 7f       	andi	r18, 0xF0	; 240
 ca0:	20 25       	eor	r18, r0
 ca2:	03 2e       	mov	r0, r19
 ca4:	32 2f       	mov	r19, r18
 ca6:	22 95       	swap	r18
 ca8:	2f 70       	andi	r18, 0x0F	; 15
 caa:	02 26       	eor	r0, r18
 cac:	26 95       	lsr	r18
 cae:	32 27       	eor	r19, r18
 cb0:	23 27       	eor	r18, r19
 cb2:	22 0f       	add	r18, r18
 cb4:	22 0f       	add	r18, r18
 cb6:	22 0f       	add	r18, r18
 cb8:	20 25       	eor	r18, r0
 cba:	85 81       	ldd	r24, Z+5	; 0x05
 cbc:	28 27       	eor	r18, r24
 cbe:	02 2e       	mov	r0, r18
 cc0:	22 95       	swap	r18
 cc2:	20 7f       	andi	r18, 0xF0	; 240
 cc4:	20 25       	eor	r18, r0
 cc6:	03 2e       	mov	r0, r19
 cc8:	32 2f       	mov	r19, r18
 cca:	22 95       	swap	r18
 ccc:	2f 70       	andi	r18, 0x0F	; 15
 cce:	02 26       	eor	r0, r18
 cd0:	26 95       	lsr	r18
 cd2:	32 27       	eor	r19, r18
 cd4:	23 27       	eor	r18, r19
 cd6:	22 0f       	add	r18, r18
 cd8:	22 0f       	add	r18, r18
 cda:	22 0f       	add	r18, r18
 cdc:	20 25       	eor	r18, r0
 cde:	86 81       	ldd	r24, Z+6	; 0x06
 ce0:	28 27       	eor	r18, r24
 ce2:	02 2e       	mov	r0, r18
 ce4:	22 95       	swap	r18
 ce6:	20 7f       	andi	r18, 0xF0	; 240
 ce8:	20 25       	eor	r18, r0
 cea:	03 2e       	mov	r0, r19
 cec:	32 2f       	mov	r19, r18
 cee:	22 95       	swap	r18
 cf0:	2f 70       	andi	r18, 0x0F	; 15
 cf2:	02 26       	eor	r0, r18
 cf4:	26 95       	lsr	r18
 cf6:	32 27       	eor	r19, r18
 cf8:	23 27       	eor	r18, r19
 cfa:	22 0f       	add	r18, r18
 cfc:	22 0f       	add	r18, r18
 cfe:	22 0f       	add	r18, r18
 d00:	20 25       	eor	r18, r0
 d02:	87 81       	ldd	r24, Z+7	; 0x07
 d04:	28 27       	eor	r18, r24
 d06:	02 2e       	mov	r0, r18
 d08:	22 95       	swap	r18
 d0a:	20 7f       	andi	r18, 0xF0	; 240
 d0c:	20 25       	eor	r18, r0
 d0e:	03 2e       	mov	r0, r19
 d10:	32 2f       	mov	r19, r18
 d12:	22 95       	swap	r18
 d14:	2f 70       	andi	r18, 0x0F	; 15
 d16:	02 26       	eor	r0, r18
 d18:	26 95       	lsr	r18
 d1a:	32 27       	eor	r19, r18
 d1c:	23 27       	eor	r18, r19
 d1e:	22 0f       	add	r18, r18
 d20:	22 0f       	add	r18, r18
 d22:	22 0f       	add	r18, r18
 d24:	20 25       	eor	r18, r0
 d26:	80 85       	ldd	r24, Z+8	; 0x08
 d28:	28 27       	eor	r18, r24
 d2a:	02 2e       	mov	r0, r18
 d2c:	22 95       	swap	r18
 d2e:	20 7f       	andi	r18, 0xF0	; 240
 d30:	20 25       	eor	r18, r0
 d32:	03 2e       	mov	r0, r19
 d34:	32 2f       	mov	r19, r18
 d36:	22 95       	swap	r18
 d38:	2f 70       	andi	r18, 0x0F	; 15
 d3a:	02 26       	eor	r0, r18
 d3c:	26 95       	lsr	r18
 d3e:	32 27       	eor	r19, r18
 d40:	23 27       	eor	r18, r19
 d42:	22 0f       	add	r18, r18
 d44:	22 0f       	add	r18, r18
 d46:	22 0f       	add	r18, r18
 d48:	20 25       	eor	r18, r0
 d4a:	81 85       	ldd	r24, Z+9	; 0x09
 d4c:	28 27       	eor	r18, r24
 d4e:	02 2e       	mov	r0, r18
 d50:	22 95       	swap	r18
 d52:	20 7f       	andi	r18, 0xF0	; 240
 d54:	20 25       	eor	r18, r0
 d56:	03 2e       	mov	r0, r19
 d58:	32 2f       	mov	r19, r18
 d5a:	22 95       	swap	r18
 d5c:	2f 70       	andi	r18, 0x0F	; 15
 d5e:	02 26       	eor	r0, r18
 d60:	26 95       	lsr	r18
 d62:	32 27       	eor	r19, r18
 d64:	23 27       	eor	r18, r19
 d66:	22 0f       	add	r18, r18
 d68:	22 0f       	add	r18, r18
 d6a:	22 0f       	add	r18, r18
 d6c:	20 25       	eor	r18, r0
    const uint8_t *rawmsg = (const uint8_t*)msg;
    uint16_t crc = 0xFFFF;
    for (i = 0; i<sizeof(message_t)-sizeof(msg->crc); i++)
        crc = _crc_ccitt_update(crc, rawmsg[i]);
    return crc;
}
 d6e:	c9 01       	movw	r24, r18
 d70:	08 95       	ret

00000d72 <message_send>:
 d72:	0f b6       	in	r0, 0x3f	; 63
 d74:	a4 b1       	in	r26, 0x04	; 4
 d76:	20 91 03 01 	lds	r18, 0x0103
 d7a:	2a 2b       	or	r18, r26
 d7c:	24 b9       	out	0x04, r18	; 4
 d7e:	21 e0       	ldi	r18, 0x01	; 1
 d80:	30 91 03 01 	lds	r19, 0x0103
 d84:	20 30       	cpi	r18, 0x00	; 0
 d86:	29 f0       	breq	.+10     	; 0xd92 <message_send+0x20>
 d88:	00 00       	nop
 d8a:	25 b1       	in	r18, 0x05	; 5
 d8c:	23 2b       	or	r18, r19
 d8e:	25 b9       	out	0x05, r18	; 5
 d90:	04 c0       	rjmp	.+8      	; 0xd9a <message_send+0x28>
 d92:	00 00       	nop
 d94:	00 00       	nop
 d96:	00 00       	nop
 d98:	00 c0       	rjmp	.+0      	; 0xd9a <message_send+0x28>
 d9a:	00 00       	nop
 d9c:	00 00       	nop
 d9e:	00 00       	nop
 da0:	30 95       	com	r19
 da2:	25 b1       	in	r18, 0x05	; 5
 da4:	23 23       	and	r18, r19
 da6:	25 b9       	out	0x05, r18	; 5
 da8:	2e ea       	ldi	r18, 0xAE	; 174
 daa:	2a 95       	dec	r18
 dac:	f1 f7       	brne	.-4      	; 0xdaa <message_send+0x38>
 dae:	2b ee       	ldi	r18, 0xEB	; 235

00000db0 <checkcollision>:
 db0:	30 b7       	in	r19, 0x30	; 48
 db2:	35 ff       	sbrs	r19, 5
 db4:	0a c0       	rjmp	.+20     	; 0xdca <nocollision>
 db6:	a4 b9       	out	0x04, r26	; 4
 db8:	30 91 03 01 	lds	r19, 0x0103
 dbc:	30 95       	com	r19
 dbe:	25 b1       	in	r18, 0x05	; 5
 dc0:	23 23       	and	r18, r19
 dc2:	25 b9       	out	0x05, r18	; 5
 dc4:	0f be       	out	0x3f, r0	; 63
 dc6:	80 e0       	ldi	r24, 0x00	; 0
 dc8:	08 95       	ret

00000dca <nocollision>:
 dca:	00 00       	nop
 dcc:	2a 95       	dec	r18
 dce:	81 f7       	brne	.-32     	; 0xdb0 <checkcollision>
 dd0:	21 e0       	ldi	r18, 0x01	; 1
 dd2:	30 91 03 01 	lds	r19, 0x0103
 dd6:	20 30       	cpi	r18, 0x00	; 0
 dd8:	29 f0       	breq	.+10     	; 0xde4 <nocollision+0x1a>
 dda:	00 00       	nop
 ddc:	25 b1       	in	r18, 0x05	; 5
 dde:	23 2b       	or	r18, r19
 de0:	25 b9       	out	0x05, r18	; 5
 de2:	04 c0       	rjmp	.+8      	; 0xdec <nocollision+0x22>
 de4:	00 00       	nop
 de6:	00 00       	nop
 de8:	00 00       	nop
 dea:	00 c0       	rjmp	.+0      	; 0xdec <nocollision+0x22>
 dec:	00 00       	nop
 dee:	00 00       	nop
 df0:	00 00       	nop
 df2:	30 95       	com	r19
 df4:	25 b1       	in	r18, 0x05	; 5
 df6:	23 23       	and	r18, r19
 df8:	25 b9       	out	0x05, r18	; 5
 dfa:	00 00       	nop
 dfc:	24 e5       	ldi	r18, 0x54	; 84
 dfe:	2a 95       	dec	r18
 e00:	f1 f7       	brne	.-4      	; 0xdfe <nocollision+0x34>
 e02:	fc 01       	movw	r30, r24
 e04:	8c e0       	ldi	r24, 0x0C	; 12

00000e06 <sendbyte>:
 e06:	61 91       	ld	r22, Z+
 e08:	70 e0       	ldi	r23, 0x00	; 0
 e0a:	66 0f       	add	r22, r22
 e0c:	77 1f       	adc	r23, r23
 e0e:	61 60       	ori	r22, 0x01	; 1
 e10:	72 60       	ori	r23, 0x02	; 2
 e12:	9a e0       	ldi	r25, 0x0A	; 10
 e14:	41 e0       	ldi	r20, 0x01	; 1
 e16:	50 e0       	ldi	r21, 0x00	; 0

00000e18 <sendbit>:
 e18:	9a 01       	movw	r18, r20
 e1a:	26 23       	and	r18, r22
 e1c:	37 23       	and	r19, r23
 e1e:	23 2b       	or	r18, r19
 e20:	30 91 03 01 	lds	r19, 0x0103
 e24:	20 30       	cpi	r18, 0x00	; 0
 e26:	29 f0       	breq	.+10     	; 0xe32 <sendbit+0x1a>
 e28:	00 00       	nop
 e2a:	25 b1       	in	r18, 0x05	; 5
 e2c:	23 2b       	or	r18, r19
 e2e:	25 b9       	out	0x05, r18	; 5
 e30:	04 c0       	rjmp	.+8      	; 0xe3a <sendbit+0x22>
 e32:	00 00       	nop
 e34:	00 00       	nop
 e36:	00 00       	nop
 e38:	00 c0       	rjmp	.+0      	; 0xe3a <sendbit+0x22>
 e3a:	00 00       	nop
 e3c:	00 00       	nop
 e3e:	00 00       	nop
 e40:	30 95       	com	r19
 e42:	25 b1       	in	r18, 0x05	; 5
 e44:	23 23       	and	r18, r19
 e46:	25 b9       	out	0x05, r18	; 5
 e48:	00 00       	nop
 e4a:	21 e5       	ldi	r18, 0x51	; 81
 e4c:	2a 95       	dec	r18
 e4e:	f1 f7       	brne	.-4      	; 0xe4c <sendbit+0x34>
 e50:	44 0f       	add	r20, r20
 e52:	55 1f       	adc	r21, r21
 e54:	9a 95       	dec	r25
 e56:	01 f7       	brne	.-64     	; 0xe18 <sendbit>
 e58:	8a 95       	dec	r24
 e5a:	a9 f6       	brne	.-86     	; 0xe06 <sendbyte>
 e5c:	20 b7       	in	r18, 0x30	; 48
 e5e:	20 61       	ori	r18, 0x10	; 16
 e60:	20 bf       	out	0x30, r18	; 48
 e62:	a4 b9       	out	0x04, r26	; 4
 e64:	30 91 03 01 	lds	r19, 0x0103
 e68:	30 95       	com	r19
 e6a:	25 b1       	in	r18, 0x05	; 5
 e6c:	23 23       	and	r18, r19
 e6e:	25 b9       	out	0x05, r18	; 5
 e70:	0f be       	out	0x3f, r0	; 63
 e72:	81 e0       	ldi	r24, 0x01	; 1
 e74:	08 95       	ret

00000e76 <_exit>:
 e76:	f8 94       	cli

00000e78 <__stop_program>:
 e78:	ff cf       	rjmp	.-2      	; 0xe78 <__stop_program>
